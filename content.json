{"meta":{"title":"maple博客","subtitle":null,"description":null,"author":"maple","url":"https://conjurermaple.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-02-22T06:55:02.968Z","updated":"2019-02-21T11:24:38.160Z","comments":false,"path":"/404.html","permalink":"https://conjurermaple.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2019-02-22T07:12:07.916Z","updated":"2019-02-21T11:24:38.163Z","comments":false,"path":"books/index.html","permalink":"https://conjurermaple.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-02-22T06:50:12.087Z","updated":"2019-02-21T11:24:38.162Z","comments":false,"path":"about/index.html","permalink":"https://conjurermaple.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2019-02-23T12:10:06.024Z","updated":"2019-02-21T11:24:38.164Z","comments":false,"path":"categories/index.html","permalink":"https://conjurermaple.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-02-21T11:24:38.166Z","updated":"2019-02-21T11:24:38.166Z","comments":false,"path":"repository/index.html","permalink":"https://conjurermaple.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-02-21T11:24:38.165Z","updated":"2019-02-21T11:24:38.165Z","comments":true,"path":"links/index.html","permalink":"https://conjurermaple.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-21T11:24:38.167Z","updated":"2019-02-21T11:24:38.167Z","comments":false,"path":"tags/index.html","permalink":"https://conjurermaple.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"shiro单用登录(同一时刻只能登录一个账号)","slug":"shiro单用登录-同一时刻只能登录一个账号","date":"2019-03-31T14:12:02.000Z","updated":"2019-03-31T14:20:27.573Z","comments":true,"path":"2019/03/31/shiro单用登录-同一时刻只能登录一个账号/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/shiro单用登录-同一时刻只能登录一个账号/","excerpt":"","text":"applicationContext-shiro.xml123456789101112131415161718192021222324&lt;bean id=&quot;myRealm&quot; class=&quot;com.sys.shiro.MyRealm&quot; /&gt; &lt;bean id=&quot;sessionDAO&quot; class=&quot;org.apache.shiro.session.mgt.eis.MemorySessionDAO&quot;&gt; &lt;/bean&gt;&lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot; /&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;sessionValidationInterval&quot; value=&quot;1800000&quot; /&gt; &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot; /&gt; &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt; &lt;/bean&gt;&lt;!-- Shiro默认会使用Servlet容器的Session,可通过sessionMode属性来指定使用Shiro原生Session --&gt; &lt;!-- 即&lt;property name=&quot;sessionMode&quot; value=&quot;native&quot;/&gt;,详细说明见官方文档 --&gt; &lt;!-- 这里主要是设置自定义的单Realm应用,若有多个Realm,可使用&apos;realms&apos;属性代替 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroCacheManager&quot; /&gt; &lt;property name=&quot;realm&quot; ref=&quot;myRealm&quot; /&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt; &lt;/bean&gt; controller12345678910111213141516171819202122232425262728293031323334353637383940414243@RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST) @ResponseBody public JsonResult login(String username, String password,String code,HttpServletRequest request) &#123; String random = (String)request.getSession().getAttribute(&quot;RANDOMCODE_IN_SESSION&quot;); boolean same = RandomCodeUtils.isSame(random, code); if (!same) &#123; //验证码不同 return new JsonResult(false,&quot;验证码不正确&quot;); &#125; Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); for (Session session : sessions) &#123; System.out.println(&quot;登录用户&quot; + session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY)); if (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) != null) &#123; return new JsonResult(false,&quot;该用户已经登录&quot;); &#125; &#125; //拿到当前用户 Subject subject = SecurityUtils.getSubject(); //判断是否登录 if (!subject.isAuthenticated()) &#123; try &#123; UsernamePasswordToken token = new UsernamePasswordToken(username,password); subject.login(token); &#125; catch (UnknownAccountException e) &#123; e.printStackTrace(); System.err.println(&quot;用户名不正确&quot;); return new JsonResult(false,&quot;用户名或密码错误&quot;); &#125; catch (IncorrectCredentialsException e) &#123; e.printStackTrace(); System.err.println(&quot;密码不正确&quot;); return new JsonResult(false,&quot;用户名或密码错误&quot;); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); return new JsonResult(false,&quot;未知错误&quot;); &#125; &#125; //将当前登录用户放入session UserContext.setUser(); return new JsonResult(); &#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"datagrid三次相同请求","slug":"datagrid三次请求","date":"2019-03-31T13:59:30.000Z","updated":"2019-03-31T14:06:05.252Z","comments":true,"path":"2019/03/31/datagrid三次请求/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/datagrid三次请求/","excerpt":"","text":"打开一个页面发现有三次相同请求我用html创建的 性能及其低下 解决方案：尽量用js创建","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"使用easypoi集成SpringMVC进行大数据导出","slug":"使用easypoi集成SpringMVC进行大数据导出","date":"2019-03-31T13:45:45.000Z","updated":"2019-03-31T13:53:01.962Z","comments":true,"path":"2019/03/31/使用easypoi集成SpringMVC进行大数据导出/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/使用easypoi集成SpringMVC进行大数据导出/","excerpt":"","text":"导包 导入easypoi的包，注意：要去掉poi的包，有冲突 12345678910111213141516&lt;!-- easypoi的支持 使用easypoi要取消poi的包-有冲突 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-base&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-web&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-annotation&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; 新建domain我现在数据库里插入了接近一百万条数据1234567891011121314151617//这里使用了jpa我这里做测试，就简单建了@Entity@Table(name = &quot;bigdata&quot;)public class BigData extends BaseDomain&#123; @Excel(name = &quot;名称&quot;,width = 15) private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 新建ExcelExportServer要使用easypoi的大数据导出，需要实现IExcelExportServer接口 12345678910111213public class MyExcelExportServer implements IExcelExportServer &#123; @Autowired private IBigDataService bigDataService; @Override public List&lt;Object&gt; selectListForExcelExport(Object o, int i) &#123; //i是页码，自动传入，进行分页查询 List list = bigDataService.queryLimit(i); System.out.println(&quot;----------&quot;+i); return list; &#125;&#125; applicationContext-mvc.xml配置12345//固定写法&lt;context:component-scan base-package=&quot;cn.afterturn.easypoi.handler.inter&quot;/&gt;//实现IExcelExportServer接口的类&lt;bean class=&quot;cn.pj.aisell.common.MyExcelExportServer&quot;/&gt; controller代码 注意：这里有一个坑，发现不能有title，不然会报错，我已经注释了 12345678910111213141516171819//大数据导出` @RequestMapping(&quot;/bigdata&quot;) public void downloadByPoiBaseView(ModelMap map, HttpServletRequest request, HttpServletResponse response) &#123;// ExportParams params = new ExportParams(&quot;2412312&quot;, &quot;测试&quot;, ExcelType.XSSF); long start = new Date().getTime(); ExportParams params = new ExportParams();// params.setFreezeCol(2); map.put(BigExcelConstants.CLASS, BigData.class); map.put(BigExcelConstants.PARAMS, params); map.put(BigExcelConstants.FILE_NAME, &quot;lala&quot;); //就是我们的查询参数,会带到接口中,供接口查询使用 map.put(BigExcelConstants.DATA_PARAMS, new HashMap&lt;String,String&gt;()); map.put(BigExcelConstants.DATA_INTER,excelExportServer ); PoiBaseView.render(map, request, response, BigExcelConstants.EASYPOI_BIG_EXCEL_VIEW); long end = new Date().getTime(); System.out.println(&quot;总共用时:&quot;+(end-start)); &#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"spring发送邮件","slug":"spring发送邮件","date":"2019-03-31T13:39:38.000Z","updated":"2019-03-31T13:43:12.239Z","comments":true,"path":"2019/03/31/spring发送邮件/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/spring发送邮件/","excerpt":"","text":"场景：忘记密码发送邮件 导包12345&lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt; applicationContext.xml配置1234567891011121314151617&lt;bean id=&quot;mailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt; &lt;!-- 163邮箱,smtp.163.com --&gt; &lt;!-- admin@163.com 用户名:admin 密码:xxx --&gt; &lt;!-- smtp邮件发送协议 --&gt; &lt;!-- pop3收邮件协议 --&gt; &lt;property name=&quot;host&quot; value=&quot;smtp.163.com&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;123456&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;开启POP3/SMTP服务，生成的授权码&quot; /&gt; &lt;property name=&quot;javaMailProperties&quot;&gt; &lt;props&gt; &lt;!-- 必须进行授权认证，它的目的就是阻止他人任意乱发邮件 --&gt; &lt;prop key=&quot;mail.smtp.auth&quot;&gt;true&lt;/prop&gt; &lt;!-- SMTP加密方式:连接到一个TLS保护连接 --&gt; &lt;prop key=&quot;mail.smtp.starttls.enable&quot;&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 注意:发送的邮箱要开启POP3/SMTP服务，生成授权码 controller代码12345678910111213141516171819try &#123; //设定mail server senderImpl.setHost(&quot;smtp.qq.com&quot;); //建立邮件消息,发送简单邮件和html邮件的区别 MimeMessage mailMessage = senderImpl.createMimeMessage(); MimeMessageHelper messageHelper = new MimeMessageHelper(mailMessage,&quot;UTF-8&quot;); //设置收件人，寄件人 messageHelper.setTo(email); messageHelper.setFrom(&quot;xxxx@qq.com&quot;); messageHelper.setSubject(&quot;密码找回&quot;); //true 表示启动HTML格式的邮件 messageHelper.setText(&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&apos;&apos;&gt;点击链接找回密码&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&quot;,true); //发送邮件 senderImpl.send(mailMessage); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"shiro有对应的权限才能显示按钮","slug":"shiro有对应的权限才能显示按钮","date":"2019-03-31T09:56:50.000Z","updated":"2019-03-31T09:57:17.703Z","comments":true,"path":"2019/03/31/shiro有对应的权限才能显示按钮/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/shiro有对应的权限才能显示按钮/","excerpt":"","text":"没有这个权限,就不展示对应的按键12345&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;...&lt;shiro:hasPermission name=&quot;employee:delete&quot;&gt; &lt;a href=&quot;javascript:;&quot; data-method=&quot;delete&quot; class=&quot;easyui-linkbutton&quot; iconCls=&quot;icon-remove&quot; plain=&quot;true&quot;&gt;删除&lt;/a&gt;&lt;/shiro:hasPermission&gt;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"菜单管理双向多对一配置","slug":"菜单管理双向多对一配置","date":"2019-03-31T09:52:56.000Z","updated":"2019-03-31T09:56:02.857Z","comments":true,"path":"2019/03/31/菜单管理双向多对一配置/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/菜单管理双向多对一配置/","excerpt":"","text":"1. 菜单管理配置 员工 -&gt; 角色 -&gt; 权限 -&gt; 菜单 1.1 Menu 菜单domain的自关连配置 需要配置双向,但是不能让JPA去管理一对多(我们自己管理:@Transient) 双向生成JSON会产生死循环,需要一边进行忽略:@JsonIgnore 123456789//让它不再生成JSON @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;parent_id&quot;) @JsonIgnore private Menu parent; // 临时属性 -&gt; 这个字段JPA就不管它了 @Transient private List&lt;Menu&gt; children = new ArrayList&lt;&gt;(); 1.2 MenuRepository1234public interface MenuRepository extends BaseRepository&lt;Menu,Long&gt;&#123; @Query(&quot;select distinct m from Employee e join e.roles r join r.permissions p join p.menu m where e.id = ?1&quot;) List&lt;Menu&gt; findByUser(Long userId);&#125; 1.3 MenuService 根据设计只能通过员工找到子菜单 需要通过子菜单拿到父菜单 判断这个父菜单是否已经存到集合中 如果这个菜单单没有存起来,放到集合中 把当前这个子菜单放到父菜单中去 123456789101112131415161718192021@Overridepublic List&lt;Menu&gt; findLoginMenu() &#123; //1.准备一个装父菜单的容器 List&lt;Menu&gt; parentMenus = new ArrayList&lt;&gt;(); //2.拿到当前登录用户的所有子菜单 Employee loginUser = UserContext.getUser(); List&lt;Menu&gt; children = menuRepository.findByUser(loginUser.getId()); //3.遍历子菜单，设置它们的关系 for (Menu child : children) &#123; //3.1 根据子菜单拿到它对应的父菜单 Menu parent = child.getParent(); //3.2 判断这个父菜单是否在容器中 if(!parentMenus.contains(parent))&#123; //3.3 如果不在，把父菜单放进去 parentMenus.add(parent); &#125; //3.4 为这个父菜单添加对应的子菜单 parent.getChildren().add(child); &#125; return parentMenus;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"shiro-ajax请求的权限处理","slug":"shiro-ajax请求的权限处理","date":"2019-03-31T09:06:15.000Z","updated":"2019-03-31T09:08:39.078Z","comments":true,"path":"2019/03/31/shiro-ajax请求的权限处理/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/shiro-ajax请求的权限处理/","excerpt":"","text":"shiro处理没有权限是跳转页面,而我们如果是ajax请求,我们希望是返回json数据 ajax请求会有一个请求头:X-Requested-With: XMLHttpRequest 需要自定义一个shiro的权限过滤器 自定义权限过滤器123456789101112131415161718192021222324252627282930313233public class AisellPermissionsAuthorizationFilter extends PermissionsAuthorizationFilter &#123; protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException &#123; Subject subject = getSubject(request, response); // If the subject isn&apos;t identified, redirect to login URL if (subject.getPrincipal() == null) &#123; saveRequestAndRedirectToLogin(request, response); &#125; else &#123; //一.拿到请求头 HttpServletRequest req = (HttpServletRequest)request; // 拿到响应头 HttpServletResponse resp = (HttpServletResponse)response; //设置响应头 resp.setContentType(&quot;application/json;charset=UTF-8&quot;); String xr = req.getHeader(&quot;X-Requested-With&quot;); //二.判断这个请求头是否是Ajax请求 if(xr!=null &amp;&amp; &quot;XMLHttpRequest&quot;.equals(xr))&#123; //返回一个json &#123;&quot;success&quot;:false,&quot;msg&quot;:&quot;权限不足，请充值！&quot;&#125; resp.getWriter().print(&quot;&#123;\\&quot;success\\&quot;:false,\\&quot;msg\\&quot;:\\&quot;你的权限不足，请充值！\\&quot;&#125;&quot;); &#125;else &#123; //普通请求:拿到没有权限的跳转路径,进行跳转 String unauthorizedUrl = getUnauthorizedUrl(); if (StringUtils.hasText(unauthorizedUrl)) &#123; WebUtils.issueRedirect(request, response, unauthorizedUrl); &#125; else &#123; WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED); &#125; &#125; &#125; return false; &#125;&#125; applicationContext-shiro.xml配置权限过滤器12345678910111213&lt;!-- 真正实现权限的过滤器 它的id名称和web.xml中的过滤器名称一样 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; ... &lt;!-- 设置权限过滤器 --&gt; &lt;property name=&quot;filters&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aisellPerms&quot; value-ref=&quot;aisellPermissionsAuthorizationFilter&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置自定义shiro过滤器 --&gt; &lt;bean id=&quot;aisellPermissionsAuthorizationFilter&quot; class=&quot;cn.itsource.aisell.shiro.AisellPermissionsAuthorizationFilter&quot; /&gt; 修改过滤器配置 123456789101112@Autowiredprivate IPermissionService permissionService;public Map&lt;String,String&gt; createFilterChainDefinitionMap()&#123; ... //拿到所有权限 List&lt;Permission&gt; perms = permissionService.findAll(); //设置相应的权限 perms.forEach(p -&gt; &#123; filterChainDefinitionMap.put(p.getUrl(), &quot;aisellPerms[&quot;+p.getSn()+&quot;]&quot;); &#125;); ...&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"shiro-UserContext(工具类-存取用户)","slug":"UserContext-工具类-存取用户","date":"2019-03-31T08:58:25.000Z","updated":"2019-03-31T08:59:45.600Z","comments":true,"path":"2019/03/31/UserContext-工具类-存取用户/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/UserContext-工具类-存取用户/","excerpt":"","text":"session是从subject获取 存在shiro的session中后，HttpSession也会有值 123456789101112131415161718192021222324public class UserContext &#123; public static final String USER_IN_SESSION =&quot;loginUser&quot;; //把登录成功的用户放到session中 public static void setUser(Employee loginUser)&#123; Subject subject = SecurityUtils.getSubject(); //代表登录成功,把当前登录用户放到Session中去(shiro的session) //1.拿到session Session session = subject.getSession(); //2.把当前登录成功的用户放到session中去 session.setAttribute(USER_IN_SESSION, loginUser); &#125; //获取到当前登录用户 public static Employee getUser()&#123; Subject subject = SecurityUtils.getSubject(); Session session = subject.getSession(); Employee employee = (Employee) session.getAttribute(USER_IN_SESSION); return employee; &#125;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"shiro里的主体(Principal)","slug":"shiro里的主体-Principal","date":"2019-03-31T08:51:08.000Z","updated":"2019-03-31T08:52:44.757Z","comments":true,"path":"2019/03/31/shiro里的主体-Principal/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/shiro里的主体-Principal/","excerpt":"","text":"登录成功后主体为用户对象1234567//身份认证@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; ... SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(loginUser,password,salt,getName()); return authenticationInfo;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"shiro展示用户名与注销","slug":"shiro展示用户名与注销","date":"2019-03-31T08:30:54.000Z","updated":"2019-03-31T08:31:59.393Z","comments":true,"path":"2019/03/31/shiro展示用户名与注销/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/shiro展示用户名与注销/","excerpt":"","text":"main.jsp 123456&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;... &lt;div style=&quot;text-align: right;margin-right: 20px;&quot;&gt; 欢迎您,亲爱的用户:&lt;shiro:principal /&gt; &lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt;&lt;/div&gt; LoginController123456@RequestMapping(&quot;/logout&quot;)public String logout()&#123; Subject currentUser = SecurityUtils.getSubject(); currentUser.logout(); return &quot;redirect:/login&quot;;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"回车登录","slug":"回车登录","date":"2019-03-31T08:26:56.000Z","updated":"2019-03-31T08:28:42.359Z","comments":true,"path":"2019/03/31/回车登录/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/回车登录/","excerpt":"","text":"敲下回车键进行登录12345678$(document.documentElement).on(&quot;keyup&quot;, function(event) &#123; //console.debug(event.keyCode); var keyCode = event.keyCode; console.debug(keyCode); if (keyCode === 13) &#123; // 捕获回车 submitForm(); // 提交表单的方法 &#125;&#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://conjurermaple.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://conjurermaple.github.io/tags/javascript/"}]},{"title":"注销登陆跳出顶层页面","slug":"注销登陆跳出顶层页面","date":"2019-03-31T08:24:51.000Z","updated":"2019-03-31T08:26:37.090Z","comments":true,"path":"2019/03/31/注销登陆跳出顶层页面/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/注销登陆跳出顶层页面/","excerpt":"","text":"使用iframe时，注销登陆跳出顶层页面在登录页面加入以下代码12345// 检查自己是否是顶级页面if (top != window) &#123;// 如果不是顶级 //把子页面的地址，赋值给顶级页面显示 window.top.location.href = window.location.href;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://conjurermaple.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://conjurermaple.github.io/tags/javascript/"}]},{"title":"shiro完成基本登录","slug":"shiro完成基本登录","date":"2019-03-31T07:47:56.000Z","updated":"2019-03-31T08:23:35.523Z","comments":true,"path":"2019/03/31/shiro完成基本登录/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/shiro完成基本登录/","excerpt":"","text":"1. 完成基本登录功能controller登录方法123456789101112131415161718192021222324252627@RequestMapping(value=&quot;/login&quot;,method = RequestMethod.POST)@ResponseBodypublic JsonResult login(String username, String password)&#123; //1.拿到当前用户 Subject currentUser = SecurityUtils.getSubject(); //2.如果没有登录,进行登录 if(!currentUser.isAuthenticated())&#123; //3.准备令牌 UsernamePasswordToken token = new UsernamePasswordToken(username, password); //4.实现登录 try &#123; currentUser.login(token); &#125; catch (UnknownAccountException e) &#123; e.printStackTrace(); return new JsonResult(false, &quot;用户名不存在！&quot;); &#125; catch (IncorrectCredentialsException e) &#123; e.printStackTrace(); return new JsonResult(false, &quot;账号或密码错误！&quot;); &#125; catch (AuthenticationException e) &#123; e.printStackTrace();// System.out.println(&quot;就是登录不了(请联系程序员...)&quot;); return new JsonResult(false, &quot;网络出错(联系管理员)！&quot;); &#125; &#125; //登录成功成功令牌 return new JsonResult();&#125; 1.1 登录细节1.1.1 数据库的密码设置 要有一套自己的密码规则(md5,10次,盐值:itsource) ① MD5Util.java 1234567891011public class MD5Util &#123; public static final String SALT = &quot;itsource&quot;; public static final Integer HASHITERATIONS = 10; //密码加密 public static String changePwd(String password)&#123; SimpleHash hash = new SimpleHash(&quot;MD5&quot;,password,SALT,HASHITERATIONS); return hash.toHex(); &#125;&#125; ② 添加用户密码加密 controller或者service中都可以进行[我们选择service]12345678@Overridepublic void save(Employee employee) &#123; if(employee.getId()==null)&#123; //添加功能就进行密码修改 employee.setPassword(MD5Util.changePwd(employee.getPassword())); &#125; employeeRepository.save(employee);&#125; ③ 加密的判断必需和规则一致 applicationContext-shiro.xml(编码方式与次数)123456789101112&lt;!-- 被引用的realm(一定会写一个自定义realm) --&gt;&lt;bean id=&quot;jpaRealm&quot; class=&quot;cn.itsource.aisell.shiro.JpaRealm&quot;&gt; &lt;!-- 为这个realm设置相应的匹配器 --&gt; &lt;property name=&quot;credentialsMatcher&quot;&gt; &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;!-- 设置加密方式 --&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot;/&gt; &lt;!-- 设置加密次数 --&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;10&quot; /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; JpaRealm(加盐一致) 12345678910111213141516171819//身份认证@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //1.拿用户名与密码 UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken; String username = token.getUsername(); //2.根据用户名拿到相应的对象 Employee loginUser = employeeService.findByUsername(username); if(loginUser==null)&#123; return null; //如果用户用空代表用户名不存在 &#125; String password = loginUser.getPassword(); //返回认证信息 //准备盐值 //传的第一个值就是主体(username名称做的主体) ByteSource salt = ByteSource.Util.bytes(MD5Util.SALT); SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,password,salt,getName()); return authenticationInfo;&#125; 1.2.1 其它细节① 静态资源放行 有些地方没有登录也可以直接使用(FilterChainDefinitionMapFactory)123456789101112131415161718public Map&lt;String,String&gt; createFilterChainDefinitionMap()&#123; //注:LinkedHashMap是有序的 Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); filterChainDefinitionMap.put(&quot;/s/login.jsp&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;); //把所有静态资源进行放行 filterChainDefinitionMap.put(&quot;*.js&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;*.css&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/easyui/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/images/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/js/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/s/permission.jsp&quot;, &quot;perms[user:index]&quot;); filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;); return filterChainDefinitionMap; &#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"shiro学习笔记(一)","slug":"shiro学习笔记-一","date":"2019-03-31T07:17:08.000Z","updated":"2019-03-31T07:44:04.616Z","comments":true,"path":"2019/03/31/shiro学习笔记-一/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/shiro学习笔记-一/","excerpt":"","text":"1. shiro认识Apache Shiro是一个强大且易用的Java安全框架,有身份验证、授权、密码学和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。与之相对的还有一个是Spring security 1.1 shiro和Spring security区别 框架 shiro Spring security 易用性 √ × 粒度 粗 细(功能多强大) 1.2 shiro的四大基石身份验证、授权、密码学和会话管理 securityManager:核心对象 realm:获取数据接口 2. shiro的核心api2.1 操作之前，先得到securityManager对象123456789 //一.创建我们自己的RealmMyRealm myRealm = new MyRealm();//二.搞一个核心对象:DefaultSecurityManager securityManager = new DefaultSecurityManager();securityManager.setRealm(myRealm);//三.把securityManager放到上下文中SecurityUtils.setSecurityManager(securityManager); 2.2 我们使用过的方法12345678910111213141516//1.拿到当前用户Subject currentUser = SecurityUtils.getSubject();//2.判断是否登录currentUser.isAuthenticated();//3.登录(需要令牌的)/** UnknownAccountException:用户名不存在 IncorrectCredentialsException:密码错误 AuthenticationException:其它错误*/ UsernamePasswordToken token = new UsernamePasswordToken(&quot;admin&quot;, &quot;123456&quot;); currentUser.login(token); //4.判断是否是这个角色/权限currentUser.hasRole(&quot;角色名&quot;)currentUser.isPermitted(&quot;权限名&quot;) 3.密码加密功能123456789/** * String algorithmName, Object source, Object salt, int hashIterations) * 第一个参数algorithmName:加密算法名称 * 第二个参数source:加密原密码 * 第三个参数salt:盐值 * 第四个参数hashIterations:加密次数 */SimpleHash hash = new SimpleHash(&quot;MD5&quot;,&quot;123456&quot;,&quot;itsource&quot;,10);System.out.println(hash.toHex()); 4.自定义Realm 继承AuthorizingRealm 实现两个方法：doGetAuthorizationInfo(授权) /doGetAuthenticationInfo(登录认证) 123456789101112131415161718//身份认证@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //1.拿用户名与密码 UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken; String username = token.getUsername(); //2.根据用户名拿对应的密码 String password = getByName(username); if(password==null)&#123; return null; //返回空代表用户名有问题 &#125; //返回认证信息 //准备盐值 ByteSource salt = ByteSource.Util.bytes(&quot;itsource&quot;); //密码是shiro自己进行判断 SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,password,salt,getName()); return authenticationInfo;&#125; 123456789101112131415//授权@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; //拿到用户名 Principal:主体(用户对象/用户名) String username = (String)principalCollection.getPrimaryPrincipal(); //拿到角色 Set&lt;String&gt; roles = findRolesBy(username); //拿到权限 Set&lt;String&gt; permis = findPermsBy(username); //把角色权限交给用户 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.setRoles(roles); authorizationInfo.setStringPermissions(permis); return authorizationInfo;&#125; 注意:如果我们的密码加密，应该怎么判断(匹配器)12345678910//一.创建我们自己的RealmMyRealm myRealm = new MyRealm();//创建一个凭证匹配器(无法设置盐值)HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();// 使用MD5的方式比较密码matcher.setHashAlgorithmName(&quot;md5&quot;);// 设置编码的迭代次数matcher.setHashIterations(10);//设置凭证匹配器(加密方式匹配)myRealm.setCredentialsMatcher(matcher); 5.集成Spring 去找：shiro-root-1.4.0-RC2\\samples\\spring 5.1 导包12345678910111213&lt;!-- shiro的支持包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; &lt;!-- shiro与Spring的集成包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; 5.2 web.xml 这个过滤器是一个代码(只关注它的名称) 12345678910111213&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 5.3 application-shiro.xml 在咱们的application引入1&lt;import resource=&quot;classpath:applicationContext-shiro.xml&quot; /&gt; 是从案例中拷备过来，进行了相应的修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;!-- 创建securityManager这个核心对象 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;!-- 设置一个realm进去 --&gt; &lt;property name=&quot;realm&quot; ref=&quot;jpaRealm&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用的realm(一定会写一个自定义realm) --&gt; &lt;bean id=&quot;jpaRealm&quot; class=&quot;cn.itsource.aisell.shiro.JpaRealm&quot;&gt; &lt;!-- 为这个realm设置相应的匹配器 --&gt; &lt;property name=&quot;credentialsMatcher&quot;&gt; &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;!-- 设置加密方式 --&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot;/&gt; &lt;!-- 设置加密次数 --&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;10&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 可以让咱们的权限判断支持【注解】方法 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;/&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; &lt;!-- 真正实现权限的过滤器 它的id名称和web.xml中的过滤器名称一样 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!-- 登录路径:如果没有登录，就会跳到这里来 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/s/login.jsp&quot;/&gt; &lt;!-- 登录成功后的跳转路径 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/s/main.jsp&quot;/&gt; &lt;!-- 没有权限跳转的路径 --&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/s/unauthorized.jsp&quot;/&gt; &lt;!-- anon:这个路径不需要登录也可以访问 authc:需要登录才可以访问 perms[depts:index]:做权限拦截 咱们以后哪些访问有权限拦截,需要从数据库中读取 --&gt; &lt;!-- &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /s/login.jsp = anon /login = anon /s/permission.jsp = perms[user:index] /depts/index = perms[depts:index] /** = authc &lt;/value&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;filterChainDefinitionMap&quot; ref=&quot;filterChainDefinitionMap&quot; /&gt; &lt;/bean&gt; &lt;!-- 实例工厂设置 --&gt; &lt;bean id=&quot;filterChainDefinitionMap&quot; factory-bean=&quot;filterChainDefinitionMapFactory&quot; factory-method=&quot;createFilterChainDefinitionMap&quot; /&gt; &lt;!-- 创建可以拿到权限map的bean --&gt; &lt;bean id=&quot;filterChainDefinitionMapFactory&quot; class=&quot;cn.itsource.aisell.shiro.FilterChainDefinitionMapFactory&quot; /&gt;&lt;/beans&gt; 5.4 获取Map过滤 注意，返回的Map必需是有序的（LinkedHashMap）1234567891011121314151617181920212223public class FilterChainDefinitionMapFactory &#123; /** * 后面这个值会从数据库中来拿 * /s/login.jsp = anon * /login = anon * /s/permission.jsp = perms[user:index] * /depts/index = perms[depts:index] * /** = authc */ public Map&lt;String,String&gt; createFilterChainDefinitionMap()&#123; //注:LinkedHashMap是有序的 Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); filterChainDefinitionMap.put(&quot;/s/login.jsp&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/s/permission.jsp&quot;, &quot;perms[user:index]&quot;); filterChainDefinitionMap.put(&quot;/depts/index&quot;, &quot;perms[depts:index]&quot;); filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;); return filterChainDefinitionMap; &#125;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"velocity学习笔记(一)","slug":"velocity学习笔记-一","date":"2019-03-31T05:17:00.000Z","updated":"2019-03-31T13:32:50.919Z","comments":true,"path":"2019/03/31/velocity学习笔记-一/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/velocity学习笔记-一/","excerpt":"","text":"模板技术velocity 默认模板的后缀vmfreemarker 默认模板的后缀ftl注意：后缀可以改 Velocity可以用来做什么 动态页面静态化:xxx.html 在后台准备数据，在前台准备模板，通过IO把数据与模板合- 并,真正的生成一个html页面出来 用作发送邮件、短信模板 代码生成器 Velocity入门1234567891011121314151617181920212223242526@Test public void testVelocity01() throws Exception &#123; //创建模板应用上下文 VelocityContext context = new VelocityContext(); context.put(&quot;msg&quot;, &quot;小张是个好同志&quot;); //拿到相应的模板(需要设置好编码) Template template = Velocity.getTemplate(&quot;temptest/hello.html&quot;,&quot;UTF-8&quot;); //准备输出流 StringWriter writer = new StringWriter(); template.merge(context, writer); System.out.println(writer); &#125; @Test public void testVelocity02() throws Exception &#123; //创建模板应用上下文 VelocityContext context = new VelocityContext(); context.put(&quot;msg&quot;, &quot;小张是个好同志&quot;); //拿到相应的模板(需要设置好编码) Template template = Velocity.getTemplate(&quot;temptest/hello.html&quot;,&quot;UTF-8&quot;); //准备输出流 File file = new File(&quot;temptest/helloNew.html&quot;); FileWriter writer = new FileWriter(file); template.merge(context, writer); writer.close(); &#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"关联关系n-to-n错误","slug":"关联关系n-to-n错误","date":"2019-03-31T05:10:52.000Z","updated":"2019-03-31T05:13:41.393Z","comments":true,"path":"2019/03/31/关联关系n-to-n错误/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/关联关系n-to-n错误/","excerpt":"","text":"员工和部门是多对一的关系1在修改部门的时候，会出现n-to-n错误,就是咱们修改的时候也在相应的修改它的部门（这时候部门是一个持久化对象，它的id是不允许进行修改的。） 解决方案：(在获到员工的时候把部门设置为空)1234567891011121314/** * 特性:在执行相应方法之前都会先执行这个方法 */@ModelAttribute(&quot;editEmployee&quot;)public Employee beforeEdit(Long id, String cmd)&#123; //有id的时候-&gt; 修改功能 if(id!=null &amp;&amp; &quot;update&quot;.equals(cmd)) &#123; Employee employee = employeeService.findOne(id); //把这个要修改的关联对象设置为null,可以解决n-to-n的问题 employee.setDepartment(null); return employee; &#125; return null;&#125;","categories":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/categories/错误积累/"}],"tags":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/tags/错误积累/"}]},{"title":"修改造成数据丢失","slug":"修改造成数据丢失","date":"2019-03-31T04:58:36.000Z","updated":"2019-03-31T05:10:20.067Z","comments":true,"path":"2019/03/31/修改造成数据丢失/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/修改造成数据丢失/","excerpt":"","text":"修改数据时，发现有些数据丢失了不能保存完整的数据 解决方式： 在这里，咱们有三个解决方案：方案一：隐藏要传递的值（只隐藏，但是数据还是需要传递，这和第一个项目是同相同的方案）这个方案的优点是简单易理解，缺点是如果字段过多，代码量会比较大，另外这种方案的安全性确实是有一些低！ 方案二：在JPA的相应字段上加标签：@Column(updatable = false)private String password; 方案三：先查询数据库，获取持久状态的对象，然后把页面的数据set到对象里面(这种方案也是用得比较多的一种方案)Employee tempEmployee = employeeService.get(employee.getId());//需要修改的值就从页面里面的employee放入tempEmployeetempEmployee.setUsername(employee.getUsername());employeeService.save(tempEmployee); #使用第三种方式(@ModelAttribute注解)运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用； 代码123456789101112131415161718192021222324这时候，我们可以看到这个类所有的方法（通过路@RequestMapping）访问之前都会先访问这个方法。接下来，我们可以看一下这个是怎么传值的。在下面的传值代码中我们也解决了数据丢失的问题。//这里准备一个方法，所有方法执行前都会执行它@ModelAttribute(&quot;editEmployee&quot;)public Employee beforeEdit(Long id)&#123; if(id!=null)&#123; Employee employee = employeeService.findOne(id); return employee; &#125; return null;&#125;@RequestMapping(&quot;/save&quot;)@ResponseBodypublic Map&lt;String,Object&gt; save(Employee employee)&#123; return saveOrUpdate(employee);&#125;@RequestMapping(&quot;/update&quot;)@ResponseBodypublic Map&lt;String,Object&gt; update(@ModelAttribute(&quot;editEmployee&quot;)Employee employee)&#123; return saveOrUpdate(employee);&#125; 现在所有方法都会进入到beforeEdit中，那么只要传过来id,就会执行这个方法，这个对效率是会有影响的。所以我们可以对代码进行修改，让只有修改功能才去执行这个查询代码！！ 前台再传一个cmd=update的参数就可以了 123456789101112/** * 特性:在执行相应方法之前都会先执行这个方法 */@ModelAttribute(&quot;editEmployee&quot;)public Employee beforeEdit(Long id, String cmd)&#123; //有id的时候-&gt; 修改功能 if(id!=null &amp;&amp; &quot;update&quot;.equals(cmd)) &#123; Employee employee = employeeService.findOne(id); return employee; &#125; return null;&#125;","categories":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/categories/错误积累/"}],"tags":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/tags/错误积累/"}]},{"title":"web.xml低版本不支持EL表达式","slug":"web-xml低版本不支持EL表达式","date":"2019-03-31T03:58:48.000Z","updated":"2019-03-31T04:57:09.111Z","comments":true,"path":"2019/03/31/web-xml低版本不支持EL表达式/","link":"","permalink":"https://conjurermaple.github.io/2019/03/31/web-xml低版本不支持EL表达式/","excerpt":"","text":"现在web.xml使用提2.3的版本，这个版本是不支持EL表达式的，所以我们需要改它的头修改成2.4及以上版本！ 修改为3.1版本的 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt;&lt;/web-app&gt;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"SpringDataJPA自己扩展功能","slug":"SpringDataJPA自己扩展功能","date":"2019-03-30T13:34:08.000Z","updated":"2019-03-30T13:43:50.562Z","comments":true,"path":"2019/03/30/SpringDataJPA自己扩展功能/","link":"","permalink":"https://conjurermaple.github.io/2019/03/30/SpringDataJPA自己扩展功能/","excerpt":"","text":"BaseRepository接口直接创建BaseRepository来继承JpaRepository接口12345678910111213141516171819202122232425262728package cn.itsource.pss.repository;import cn.itsource.pss.query.BaseQuery;import org.springframework.data.domain.Page;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.repository.NoRepositoryBean;import java.io.Serializable;import java.util.List;/** * 自定义一个Repository,它是JpaRepository的功能基础上继承增强 * 在上面添加@NoRepositoryBean标注，这样Spring Data Jpa在启动时就不会去实例化BaseRepository这个接口 * @param &lt;T&gt; * @param &lt;ID&gt; */@NoRepositoryBeanpublic interface BaseRepository&lt;T,ID extends Serializable&gt; extends JpaRepository&lt;T,ID&gt;,JpaSpecificationExecutor&lt;T&gt;&#123; //根据Query拿到分页对象(分页) Page findPageByQuery(BaseQuery baseQuery); //根据Query拿到对应的所有数据(不分页) List&lt;T&gt; findByQuery(BaseQuery baseQuery); //根据jpql与对应的参数拿到数据 List findByJpql(String jpql,Object... values);&#125; BaseRepositoryImpl功能实现定义好自定义的方法后，我们现在通过一个基本的Repository类来实现该方法：首先添加BaseRepositoryImpl类，继承SimpleJpaRepository类，使其拥有Jpa Repository的基本方法。我们发现Repository有两个构造函数： SimpleJpaRepository(JpaEntityInformation entityInformation, EntityManager entityManager) SimpleJpaRepository(Class domainClass, EntityManager em)这里我们实现第二个构造函数，拿到domainClass和EntityManager两个对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.itsource.pss.repository;import cn.itsource.pss.query.BaseQuery;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.domain.Specification;import org.springframework.data.jpa.repository.support.SimpleJpaRepository;import javax.persistence.EntityManager;import javax.persistence.Query;import java.io.Serializable;import java.util.List;/** * 实现父类中的三个方法 * @param &lt;T&gt; * @param &lt;ID&gt; */public class BaseRepositoryImpl&lt;T,ID extends Serializable&gt; extends SimpleJpaRepository&lt;T,ID&gt; implements BaseRepository&lt;T,ID&gt; &#123; private final EntityManager entityManager; //必需要实现父类的这个构造器 public BaseRepositoryImpl(Class&lt;T&gt; domainClass, EntityManager em) &#123; super(domainClass, em); this.entityManager = em; &#125; @Override public Page findPageByQuery(BaseQuery baseQuery) &#123; //第一步：拿到所有高级查询条件 Specification spec = baseQuery.createSpecification(); //第二步:拿到排序的值 Sort sort = baseQuery.createSort(); //第三步:根据条件查询分页数据并且返回 Pageable pageable = new PageRequest(baseQuery.getJpaPage(), baseQuery.getPageSize(),sort); Page&lt;T&gt; page = super.findAll(spec, pageable); return page; &#125;@Override public List&lt;T&gt; findByQuery(BaseQuery baseQuery) &#123; //第一步：拿到所有高级查询条件 Specification spec = baseQuery.createSpecification(); //第二步:拿到排序的值 Sort sort = baseQuery.createSort(); //第三步:拿到数据返回 return findAll(spec, sort); &#125; @Override public List findByJpql(String jpql, Object... values) &#123; //第一步:创建Query对象 Query query = entityManager.createQuery(jpql); //第二步:把值设置到Query对象中去 if (values!=null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; query.setParameter(i + 1, values[i]); &#125; &#125; //第三步：返回数据 return query.getResultList(); &#125;&#125; 创建自定义RepositoryFactoryBean接下来我们来创建一个自定义的RepositoryFactoryBean来代替默认的RepositoryFactoryBean。RepositoryFactoryBean负责返回一个RepositoryFactory，Spring Data Jpa 将使用RepositoryFactory来创建Repository具体实现，这里我们用BaseRepositoryImpl代替SimpleJpaRepository作为Repository接口的实现。这样我们就能够达到为所有Repository添加自定义方法的目的。我们需要覆写创建RepositoryFactory的方法：createRepositoryFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.itsource.pss.repository;import org.springframework.data.jpa.repository.support.JpaRepositoryFactory;import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;import org.springframework.data.jpa.repository.support.SimpleJpaRepository;import org.springframework.data.repository.Repository;import org.springframework.data.repository.core.RepositoryInformation;import org.springframework.data.repository.core.RepositoryMetadata;import org.springframework.data.repository.core.support.RepositoryFactorySupport;import javax.persistence.EntityManager;import java.io.Serializable;public class BaseRepositoryFactoryBean&lt;T extends Repository&lt;S, ID&gt;, S, ID extends Serializable&gt; extends JpaRepositoryFactoryBean&lt;T,S,ID&gt; &#123; @Override protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) &#123; return new MyRepositoryFactory&lt;T,ID&gt;(entityManager); //注：这里创建是我们的自定义类 &#125; //继承JpaRepositoryFactory后，把返回的对象修改成我们自己的实现 private static class MyRepositoryFactory&lt;T,ID extends Serializable&gt; extends JpaRepositoryFactory&#123; private final EntityManager entityManager; /** * Creates a new &#123;@link JpaRepositoryFactory&#125;. * * @param entityManager must not be &#123;@literal null&#125; */ public MyRepositoryFactory(EntityManager entityManager) &#123; super(entityManager); this.entityManager = entityManager; &#125; //这里返回最后的功能对象 @Override protected Object getTargetRepository(RepositoryInformation information) &#123; return new BaseRepositoryImpl&lt;T,ID&gt;((Class&lt;T&gt;)information.getDomainType(),entityManager); &#125; //确定功能对象的类型 @Override protected Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) &#123; return BaseRepositoryImpl.class; &#125; &#125;&#125; applicationContext.xml 中修改配置12345&lt;!-- base-package:扫描的包 --&gt;&lt;jpa:repositories base-package=&quot;cn.itsource.pss.repository&quot; transaction-manager-ref=&quot;transactionManager&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot; factory-class=&quot;cn.itsource.pss.repository.BaseRepositoryFactoryBean&quot;/&gt; 自己写的接口继承BaseRepository 12public interface EmployeeRepository extends BaseRepository&lt;Employee,Long&gt;&#123;&#125; 测试扩展功能12345678910111213141516171819202122232425262728293031323334353637383940//测试分页查询@Testpublic void testFindPageByQuery() &#123; EmployeeQuery baseQuery = new EmployeeQuery(); baseQuery.setUsername(&quot;1&quot;); //baseQuery.setAge(20); //baseQuery.setEmail(&quot;2&quot;); baseQuery.setOrderByName(&quot;username&quot;); baseQuery.setOrderByType(&quot;DESC&quot;); //baseQuery.setCurrentPage(2); baseQuery.setPageSize(5); Page&lt;Employee&gt; page = employeeRepository.findPageByQuery(baseQuery); for (Employee employee : page) &#123; System.out.println(employee); &#125;&#125;//测试单独查询@Testpublic void findByQuery() &#123; EmployeeQuery baseQuery = new EmployeeQuery(); baseQuery.setUsername(&quot;1&quot;); //baseQuery.setAge(20); //baseQuery.setEmail(&quot;2&quot;); baseQuery.setOrderByName(&quot;username&quot;); baseQuery.setOrderByType(&quot;DESC&quot;); List&lt;Employee&gt; emps = employeeRepository.findByQuery(baseQuery); for (Employee employee : emps) &#123; System.out.println(employee); &#125;&#125;//测试自定义JPQL@Testpublic void findByJpql() &#123; List&lt;Employee&gt; emps = employeeRepository.findByJpql(&quot;select o from Employee o where username = ? and password = ?&quot;,&quot;admin&quot;,&quot;admin&quot;); for (Employee emp : emps) &#123; System.out.println(emp); &#125;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"SpringDataJPA条件查询+分页排序","slug":"SpringDataJPA条件查询-分页排序","date":"2019-03-30T13:21:47.000Z","updated":"2019-03-30T13:22:43.283Z","comments":true,"path":"2019/03/30/SpringDataJPA条件查询-分页排序/","link":"","permalink":"https://conjurermaple.github.io/2019/03/30/SpringDataJPA条件查询-分页排序/","excerpt":"","text":"123456789101112131415161718192021222324@Testpublic void testFind03() &#123; Specification spec = new Specification&lt;Employee&gt;() &#123; @Override public Predicate toPredicate(Root root, CriteriaQuery query, CriteriaBuilder cb) &#123; //加上条件: username like &apos;%1%&apos; Path path1 = root.get(&quot;username&quot;); Predicate p1 = cb.and(cb.like(path1, &quot;%1%&quot;)); //把两个查询条件放到query对象中去(条件使用where) CriteriaQuery where = query.where(p1); //返回查询条件 return where.getRestriction(); &#125; &#125;; //排序 ：第一个参数是排序的规则(DESC/ASC) 后面参数是排序的字符 Sort sort = new Sort(Sort.Direction.DESC,&quot;username&quot;); Pageable pageable = new PageRequest(0, 10,sort); Page&lt;Employee&gt; page = employeeRepository.findAll(spec, pageable); for (Employee emp : page) &#123; System.out.println(emp); &#125;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"SpringDataJPA多个条件查询","slug":"JPA多个条件查询","date":"2019-03-30T13:16:40.000Z","updated":"2019-03-30T13:22:19.743Z","comments":true,"path":"2019/03/30/JPA多个条件查询/","link":"","permalink":"https://conjurermaple.github.io/2019/03/30/JPA多个条件查询/","excerpt":"","text":"123456789101112131415161718192021222324252627282930@Testpublic void testFind02() &#123; Specification spec = new Specification&lt;Employee&gt;() &#123; @Override public Predicate toPredicate(Root root, CriteriaQuery query, CriteriaBuilder cb) &#123; //加上第一个条件: username like &apos;%1%&apos; Path path1 = root.get(&quot;username&quot;); Predicate p1 = cb.like(path1, &quot;%1%&quot;); //加上第二个条件: email like &apos;%2%&apos; Path path2 = root.get(&quot;email&quot;); Predicate p2 = cb.like(path2,&quot;%2%&quot;); //加上第二个条件: age &lt; 20 Path path3 = root.get(&quot;age&quot;); Predicate p3 = cb.lt(path3, 20); //下面是加上or的条件的方案 //Predicate p3 = cb.or(p1,p2); //把两个查询条件放到query对象中去(条件使用where) CriteriaQuery where = query.where(p1, p2, p3); //返回查询条件 return where.getRestriction(); &#125; &#125;; List&lt;Employee&gt; emps = employeeRepository.findAll(spec); for (Employee emp : emps) &#123; System.out.println(emp); &#125;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"JPA父类不持久化","slug":"JPA父类不持久化","date":"2019-03-30T12:59:42.000Z","updated":"2019-03-30T13:22:21.513Z","comments":true,"path":"2019/03/30/JPA父类不持久化/","link":"","permalink":"https://conjurermaple.github.io/2019/03/30/JPA父类不持久化/","excerpt":"","text":"123456789//在JPA里面就表示是父类，不持久化到表@MappedSuperclasspublic class BaseDomain &#123; //这里将id抽到了父类，子类就不需要再写id了 @Id @GeneratedValue protected Long id;&#125; 例如子类继承父类12345@Entity@Table(name=&quot;employee&quot;)public class Employee extends BaseDomain &#123; private String username;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"连接池配置","slug":"连接池配置","date":"2019-03-30T12:51:52.000Z","updated":"2019-03-30T13:22:22.785Z","comments":true,"path":"2019/03/30/连接池配置/","link":"","permalink":"https://conjurermaple.github.io/2019/03/30/连接池配置/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132&lt;!-- 配置连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;!--连接数据4个属性 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!--maxActive: 最大连接数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;150&quot; /&gt; &lt;!--minIdle: 最小空闲连接 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;5&quot; /&gt; &lt;!--maxIdle: 最大空闲连接 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot; /&gt; &lt;!--initialSize: 初始化连接 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;30&quot; /&gt; &lt;!-- 用来配置数据库断开后自动连接的 --&gt; &lt;!-- 连接被泄露时是否打印 --&gt; &lt;property name=&quot;logAbandoned&quot; value=&quot;true&quot; /&gt; &lt;!--removeAbandoned: 是否自动回收超时连接 --&gt; &lt;property name=&quot;removeAbandoned&quot; value=&quot;true&quot; /&gt; &lt;!--removeAbandonedTimeout: 超时时间(以秒数为单位) --&gt; &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;10&quot; /&gt; &lt;!--maxWait: 超时等待时间以毫秒为单位 1000等于60秒 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;1000&quot; /&gt; &lt;!-- 在空闲连接回收器线程运行期间休眠的时间值,以毫秒为单位. --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 在每次空闲连接回收器线程(如果有)运行时检查的连接数量 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;10&quot; /&gt; &lt;!-- 1000 * 60 * 30 连接在池中保持空闲而不被空闲连接回收器线程 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT NOW() FROM DUAL&quot; /&gt; &lt;/bean&gt;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"使用easypoi时遇到cn.afterturn.easypoi.exception.excel.ExcelImportException: 创建对象异常错误","slug":"使用easypoi时遇到cn-afterturn-easypoi-exception-excel-ExcelImportException-创建对象异常错误","date":"2019-03-23T13:06:09.000Z","updated":"2019-03-23T13:23:39.734Z","comments":true,"path":"2019/03/23/使用easypoi时遇到cn-afterturn-easypoi-exception-excel-ExcelImportException-创建对象异常错误/","link":"","permalink":"https://conjurermaple.github.io/2019/03/23/使用easypoi时遇到cn-afterturn-easypoi-exception-excel-ExcelImportException-创建对象异常错误/","excerpt":"","text":"使用easypoi做导入时 我的结构 省略getter/setter方法 我的excel文件(stu-poi.xls) 测试代码12345678910111213@Test public void test() throws Exception &#123; ImportParams params = new ImportParams(); params.setTitleRows(1); params.setHeadRows(1); List&lt;Student&gt; list = ExcelImportUtil.importExcel( new File(&quot;src/test/java/cn/pj/aisell/easypoi&quot;,&quot;stu-poi.xls&quot;), Student.class, params); list.forEach(employee -&gt; &#123; System.out.println(employee); &#125;); &#125; 出现问题的原因：提示说创建对象异常，是因为我没有给student提供无参构造，所以一直报错","categories":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/categories/错误积累/"}],"tags":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/tags/错误积累/"}]},{"title":"java.lang.ClassNotFoundException:org.springframework.web.context.ContextLoaderListener","slug":"java-lang-ClassNotFoundException-org-springframework-web-context-ContextLoaderListener","date":"2019-03-22T00:41:07.000Z","updated":"2019-03-22T00:46:52.085Z","comments":true,"path":"2019/03/22/java-lang-ClassNotFoundException-org-springframework-web-context-ContextLoaderListener/","link":"","permalink":"https://conjurermaple.github.io/2019/03/22/java-lang-ClassNotFoundException-org-springframework-web-context-ContextLoaderListener/","excerpt":"","text":"错误： 我明明导入了包，却说找不到,使用的是idea开发工具 解决方案: File &gt; Project Structure &gt; Artifacts &gt; 在右侧Output Layout右击项目名，选择Put into Output Root","categories":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/categories/错误积累/"}],"tags":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/tags/错误积累/"}]},{"title":"Spring+SpringMVC+SpringDataJPA+shiro框架集成","slug":"Spring-SpringMVC-SpringDataJPA-shiro框架集成","date":"2019-03-21T14:28:18.000Z","updated":"2019-03-21T14:45:36.510Z","comments":true,"path":"2019/03/21/Spring-SpringMVC-SpringDataJPA-shiro框架集成/","link":"","permalink":"https://conjurermaple.github.io/2019/03/21/Spring-SpringMVC-SpringDataJPA-shiro框架集成/","excerpt":"","text":"一.导包12 二.准备db.properties文件1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=数据库jdbc.username=用户名jdbc.password=密码 三. 准备spring配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt; &lt;!--扫描Spring的注解--&gt; &lt;context:component-scan base-package=&quot;cn.pj.aisell.service&quot;/&gt; &lt;!--读取properties文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--配置entityManagerFactory--&gt; &lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--扫描JPA的注解，比如@Entity--&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;cn.pj.aisell.domain&quot;/&gt; &lt;!--配置适配器，因为jpa是规范，实现太多了，配置适配器指定使用的是哪个实现--&gt; &lt;property name=&quot;jpaVendorAdapter&quot;&gt; &lt;!--Hibernate实现--&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt; &lt;!--数据库方言--&gt; &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot;/&gt; &lt;!--建表策略，值只有true和false，true表示update，false表示什么都不做--&gt; &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt; &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt; &lt;/bean&gt; &lt;!--配置支持事务的注解,transaction-manager=&quot;transactionManager&quot;名字要与上面的一样，默认找transactionManager这个名字，这里不写也可以--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;jpa:repositories base-package=&quot;cn.pj.aisell.repository&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot; transaction-manager-ref=&quot;transactionManager&quot; factory-class=&quot;cn.pj.aisell.repository.BaseRepositoryFactoryBean&quot;/&gt; &lt;!--导入shiro配置文件--&gt; &lt;import resource=&quot;classpath:applicationContext-shiro.xml&quot;/&gt;&lt;/beans&gt; 四. 准备SpringMVC配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--扫描controller--&gt; &lt;context:component-scan base-package=&quot;cn.pj.aisell.web&quot;/&gt; &lt;!--开启静态资源方法--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--扫描Springmvc注解支持--&gt; &lt;!-- Spring MVC 配置 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json; charset=UTF-8&lt;/value&gt; &lt;value&gt;application/x-www-form-urlencoded; charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- No serializer:配置 objectMapper 为我们自定义扩展后的 CustomMapper,解决了返回对象有关系对象的报错问题 --&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;cn.pj.aisell.common.CustomMapper&quot;&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--文件上传解析器--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!--上传文件最大尺寸--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;1048576&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 五. 准备shiro配置文件(shiro与spring集成)123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;aisellRealm&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;aisellRealm&quot; class=&quot;cn.pj.aisell.shiro.AisellRealm&quot;&gt; &lt;property name=&quot;credentialsMatcher&quot;&gt; &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;MD5&quot;/&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;10&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;/&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/main&quot;/&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/s/unauthorized.jsp&quot;/&gt; &lt;property name=&quot;filterChainDefinitionMap&quot; ref=&quot;myfilterChainDefinitionMap&quot;/&gt; &lt;!--&lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login = anon /images = anon /dept/index = perms[dept:index] /** = authc &lt;/value&gt; &lt;/property&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;myfilterChainDefinitionMap&quot; factory-bean=&quot;filterChainDefinitionMapBuilder&quot; factory-method=&quot;createFilterChainDefinitionMap&quot;/&gt; &lt;bean id=&quot;filterChainDefinitionMapBuilder&quot; class=&quot;cn.pj.aisell.shiro.FilterChainDefinitionMapBuilder&quot;/&gt;&lt;/beans&gt; 六. 配置web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;!--SpringMVC的核心控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;!--shiro--&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Spring监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置解决中文乱码的问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!--解决no-session问题--&gt;&lt;filter&gt; &lt;filter-name&gt;openEntityManagerInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter&lt;/filter-class&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openEntityManagerInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"No serializer found for class org.hibernate.proxy.pojo.javassist.JavassistLazyInitializer","slug":"No-serializer-found-for-class-org-hibernate-proxy-pojo-javassist-JavassistLazyInitializer","date":"2019-03-15T13:03:37.000Z","updated":"2019-03-15T13:06:34.510Z","comments":true,"path":"2019/03/15/No-serializer-found-for-class-org-hibernate-proxy-pojo-javassist-JavassistLazyInitializer/","link":"","permalink":"https://conjurermaple.github.io/2019/03/15/No-serializer-found-for-class-org-hibernate-proxy-pojo-javassist-JavassistLazyInitializer/","excerpt":"","text":"出现原因：SpringMVC与Jpa集成的时候(有懒加载)就会出现这个问题这是因为你需要序列化对象有一个属性是一类类型，而你使用了Hibernate的延迟加载所以这里是个Hibernate的代理对象。该代理对象有些属性不能被序列化所以会报错。 解决方案： 方式一：在类上加属性：生成的时候把这个字段忽略了：@JsonIgnoreProperties(value={“hibernateLazyInitializer”,”handler”,”fieldHandler”}) 方式二：123456789101112131415161718192021222324252627282930313233第一步：创建一个新的类(重写com.fasterxml.jackson.databind.ObjectMapper)package cn.itsource.pss.common;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;public class CustomMapper extends ObjectMapper &#123; public CustomMapper() &#123; this.setSerializationInclusion(JsonInclude.Include.NON_NULL); // 设置 SerializationFeature.FAIL_ON_EMPTY_BEANS 为 false this.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); &#125;&#125;第二步：在applicationContext-mvc.xml中配置一下即可&lt;!-- Spring MVC 配置 --&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json; charset=UTF-8&lt;/value&gt; &lt;value&gt;application/x-www-form-urlencoded; charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- No serializer:配置 objectMapper 为我们自定义扩展后的 CustomMapper,解决了返回对象有关系对象的报错问题 --&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;cn.itsource.pss.common.CustomMapper&quot;&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;","categories":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/categories/错误积累/"}],"tags":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/tags/错误积累/"}]},{"title":"could not initialize proxy - no Session错误","slug":"could-not-initialize-proxy-no-Session错误","date":"2019-03-15T12:52:06.000Z","updated":"2019-03-15T12:59:39.394Z","comments":true,"path":"2019/03/15/could-not-initialize-proxy-no-Session错误/","link":"","permalink":"https://conjurermaple.github.io/2019/03/15/could-not-initialize-proxy-no-Session错误/","excerpt":"","text":"出现原因：entityManager已经关闭了，然后再去操作就会出现此错误 解决方案： - 不要在关闭后再去操作 -我的情况：多对一的情况，在多方配置了懒加载 查询完多方后，可能已经关闭了，但是在前台取了一方的数据。 在web.xml里配置123456789&lt;!-- 加上OpenEntityManager --&gt;&lt;filter&gt; &lt;filter-name&gt;openEntity&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;openEntity&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","categories":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/categories/错误积累/"}],"tags":[{"name":"错误积累","slug":"错误积累","permalink":"https://conjurermaple.github.io/tags/错误积累/"}]},{"title":"SpringDataJPA学习笔记(一)","slug":"SpringDataJPA学习笔记-一","date":"2019-03-12T10:59:19.000Z","updated":"2019-03-12T11:39:06.413Z","comments":true,"path":"2019/03/12/SpringDataJPA学习笔记-一/","link":"","permalink":"https://conjurermaple.github.io/2019/03/12/SpringDataJPA学习笔记-一/","excerpt":"","text":"一. SpringDataJPA1.1 SpringDataJPA的认识 它是JPA规范的再次封装抽象，底层还是使用了Hibernate的JPA技术实现，引用JPQL的查询语句 ，是属于Spring的生成体系中的一部分。SpringDataJpa使用起来比较方便，加快了开发的效果，使开发人员不需要关心和配置更多的东西。SpringDataJpa上手简单，开发效率高，对对象的支持非常好，还十分的灵活。 1.2 导包 这是SpringDataJPA的支持包12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-data-jpa.version&#125;&lt;/version&gt; &lt;/dependency&gt; 1.3 SpringDataJPA基本配置 applicationContext.xml里写上要扫描的包,配置entityManagerFactory和事务管理器 1234&lt;jpa:repositories base-package=&quot;cn.pj.aisell.repository&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot; transaction-manager-ref=&quot;transactionManager&quot; &gt;&lt;/jpa:repositories&gt; 继承JpaRepositoryJpaRepository 接口1public interface EmployeeRepository extends JpaRepository&lt;Employee,Long&gt;, JpaSpecificationExecutor&lt;Employee&gt; 完成CRUD在测试类里，直接调用方法这里很好奇？，我们明明没有写这些方法，为啥还能调用？是因为SpringDataJPA用了代理模式，SpringDataJPA会产生一个实现我们自己定义的接口和继承了SimpleJpaRepository的实现类，我们调用的是实现类的方法12345678910employeeRepository.findAll(); employeeRepository.findOne(Long id); employeeRepository.save(对象); //添加或者修改 employeeRepository.delete(id/对象); employeeRepository.findAll(Pageable) -&gt; 分页 Pageable pageable = new PageRequest(0, 5); //0就是第一页 第二个参数是每页显示多少条 employeeRepository.findAll(Sort) -&gt; 排序 Sort sort = new Sort(Sort.Direction.DESC,&quot;username&quot;); 如果要把分页和排序结合起来: new PageRequest(0, 5,sort); 1.4 高级查询123451.名称规则 findByUsername(String username) -&gt; 根据名称查询 username = ? findByUsernameLike(String username) -&gt; username like ? findByUsernameLikeAndEmailLike(String username) -&gt; username like ? and email like ? 详细规则请看文件(idea也有提示) 规则如下： 123456789102.Query注解 @Query(&quot;jpql的语句&quot;) @Query(&quot;select o from Employee o where o.name like ?1&quot;) @Query(&quot;select o from Employee o where o.name like ?1 and o.email like ?2&quot;) //使用名称不使用下标，名称要一一对应 @Query(&quot;select o from Employee o where o.username like :username and o.email like :email&quot;) List&lt;Employee&gt; query02(@Param(&quot;username&quot;) String username, @Param(&quot;email&quot;) String email); //使用原生SQL @Query(nativeQuery = true,value=&quot;select * from employee&quot;) 二. 高级查询与分页1.1 JpaSpecificationExecutor 可以不写SQL和JPQL(HQL)也能够完成功能 12345678910111213141516171819.我们的Repository继承JpaSpecificationExecutorEmployeeRepository extends JpaRepository&lt;Employee,Long&gt;, JpaSpecificationExecutor&lt;Employee&gt;2.findAll的查询方法 employeeRepository.findAll(Specification&lt;T&gt; spec) employeeRepository.findAll(Specification&lt;T&gt; spec,Pageable pageable) new Specification&lt;Employee&gt;&#123; //root:(根,表)获取字段 //query:where,group by ,order by... //cb: 条件判断(一个或者多个) @Override public Predicate toPredicate(Root&lt;Employee&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Path path = root.get(&quot;username&quot;);//拿到要做查询的字段 Predicate p = cb.like(path, &quot;%1%&quot;);//like代表做模糊查询，后面就是它的条件值 return p; &#125; &#125; 1.2 jpa-spec使用原生的JpaSpecificationExecutor操作很复杂，这里用一个插件 12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.github.wenhao&lt;/groupId&gt; &lt;artifactId&gt;jpa-spec&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;//第一个参数: true -&gt; 条件过滤启用//第二个参数: 需要过滤的属性//第三个参数: 过滤条件的 ？对应的值Specification&lt;Person&gt; specification = Specifications.&lt;Person&gt;and() .eq(StringUtils.isNotBlank(request.getName()), &quot;name&quot;, name) .gt(Objects.nonNull(request.getAge()), &quot;age&quot;, 18) .build(); 1.3 Query(查询对象)抽取Query作用:接收前台传过来的查询条件(分页,数据)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class EmployeeQuery extends BaseQuery &#123; private String username; private String email; private Integer minAge; private Integer maxAge; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getMinAge() &#123; return minAge; &#125; public void setMinAge(Integer minAge) &#123; this.minAge = minAge; &#125; public Integer getMaxAge() &#123; return maxAge; &#125; public void setMaxAge(Integer maxAge) &#123; this.maxAge = maxAge; &#125; @Override public Specification&lt;Employee&gt; createSpecification() &#123; Specification&lt;Employee&gt; spec = Specifications.&lt;Employee&gt;and() .like(StringUtils.isNotBlank(username),&quot;username&quot;,&quot;%&quot;+username+&quot;%&quot;) .like(StringUtils.isNotBlank(email),&quot;email&quot;,&quot;%&quot;+email+&quot;%&quot;) .ge(minAge!=null,&quot;age&quot;,minAge) .le(maxAge!=null,&quot;age&quot;,maxAge) .build(); return spec; &#125;&#125; BaseQuery:公共的查询【规范,公共的代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public abstract class BaseQuery &#123; private int currentPage = 1; //当前页 private int pageSize = 10; //每页显示多少 //排序 private String orderType = &quot;ASC&quot;; //排序的类型 private String orderName; //排序的字段 public int getCurrentPage() &#123; return currentPage; &#125; public int getJpaCurrent() &#123; return currentPage-1; &#125; public void setCurrentPage(int currentPage) &#123; this.currentPage = currentPage; &#125; public Integer getPageSize() &#123; return pageSize; &#125; public void setPageSize(Integer pageSize) &#123; this.pageSize = pageSize; &#125; public String getOrderType() &#123; return orderType; &#125; public void setOrderType(String orderType) &#123; this.orderType = orderType; &#125; public String getOrderName() &#123; return orderName; &#125; public void setOrderName(String orderName) &#123; this.orderName = orderName; &#125; public Sort createSort() &#123; if (StringUtils.isNotBlank(orderName)) &#123; Sort sort = new Sort(orderName.equalsIgnoreCase(&quot;DESC&quot;)?Sort.Direction.DESC:Sort.Direction.ASC,&quot;username&quot;); return sort; &#125; return null; &#125; public abstract Specification createSpecification();&#125; 测试类 123456789101112@Test public void test07() throws Exception &#123; EmployeeQuery employeeQuery = new EmployeeQuery(); employeeQuery.setOrderName(&quot;age&quot;); employeeQuery.setUsername(&quot;admin&quot;); employeeQuery.setEmail(&quot;amdin1&quot;); employeeQuery.setMinAge(20); Pageable pageable = new PageRequest(employeeQuery.getCurrentPage(),employeeQuery.getPageSize(),employeeQuery.createSort()); Specification&lt;Employee&gt; specification = employeeQuery.createSpecification(); Page&lt;Employee&gt; employees = employeeRepository.findAll(specification,pageable); employees.forEach(e -&gt; System.out.println(e)); &#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"Bean的四种创建方式","slug":"Bean的四种创建方式","date":"2019-03-11T11:46:12.000Z","updated":"2019-03-11T11:50:04.793Z","comments":true,"path":"2019/03/11/Bean的四种创建方式/","link":"","permalink":"https://conjurermaple.github.io/2019/03/11/Bean的四种创建方式/","excerpt":"","text":"1. 普通方式 利用公共无参构造创建 1&lt;bean id=&quot;hello&quot; class=&quot;cn.itsource._10_bean.HelloBean&quot; /&gt; 1.2 FactoryBean方式 一个类实现了FactoryBean接口 执行getObject方式，返回的值也会变成一个Bean 准备一个FactoryBean 123456789101112131415161718192021222324/** * 一个类实现FactoryBean接口，那么它就是一个FactoryBean * 泛型就是它要操作的那个类型 */public class EntityManagerFactoryBean implements FactoryBean&lt;EntityManagerFactory&gt; &#123; //这个方法返回什么对象，我们拿到的bean就是什么对象 @Override public EntityManagerFactory getObject() throws Exception &#123; return Persistence.createEntityManagerFactory(); &#125; //返回的对象类型 @Override public Class&lt;?&gt; getObjectType() &#123; return EntityManagerFactory.class; &#125; //这个对象是否是单例的 @Override public boolean isSingleton() &#123; return true; &#125;&#125; 1.3 静态工厂 工厂中有一个静态方法 直接拿到这个方法中返回的对象(bean) 准备一个静态工厂 123456public class DaoFactory &#123; //在这个工厂中有一个静态方法 public static MyDao createMyDao()&#123; return new MyDao(); &#125;&#125; 配置这个工厂对应的方法 12&lt;bean id=&quot;myDao&quot; class=&quot;cn.itsource._10_bean.DaoFactory&quot; factory-method=&quot;createMyDao&quot;&gt;&lt;/bean&gt; 1.4 实例工厂 工厂中有个方法 直接拿到这个方法中返回的对象(bean) 准备一个工厂12345public class DaoFactory &#123; public MyDao createMyDao()&#123; return new MyDao(); &#125;&#125; 配置这个工厂对应的方法 123&lt;!--工厂的一个方法(非静态)--&gt;&lt;bean id=&quot;daoFactory&quot; class=&quot;cn.itsource._10_bean.DaoFactory&quot; /&gt;&lt;bean id=&quot;myDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;createMyDao&quot; /&gt;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"SSJ(Spring+SpringMvc+JPA)集成","slug":"SSJ-Spring-SpringMvc-JPA-集成","date":"2019-03-11T10:51:48.000Z","updated":"2019-03-11T11:34:46.557Z","comments":true,"path":"2019/03/11/SSJ-Spring-SpringMvc-JPA-集成/","link":"","permalink":"https://conjurermaple.github.io/2019/03/11/SSJ-Spring-SpringMvc-JPA-集成/","excerpt":"","text":"一. pom.xml(导包，插件配置) 导包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.8.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;4.3.8.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 更改JDK版本 1234567891011&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 二. SpringMVC+JPA的集成2.1 创建jdbc.properties文件（数据库连接信息）1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///ssjjdbc.username=rootjdbc.password=123456 2.2 创建applicationContext.xml2.2.1 配置数据源12345678910&lt;!--读取properties文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; 2.2.2 配置entityManagerFactory123456789101112131415161718&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--扫描JPA的注解，比如@Entity--&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;cn.pj.ssj.domain&quot;/&gt; &lt;!--配置适配器，因为jpa是规范，实现太多了，配置适配器指定使用的是哪个实现--&gt; &lt;property name=&quot;jpaVendorAdapter&quot;&gt; &lt;!--Hibernate实现--&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt; &lt;!--数据库方言--&gt; &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot;/&gt; &lt;!--建表策略，值只有true和false，true表示update，false表示什么都不做--&gt; &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 2.2.3 扫描Spring的注解123&lt;!--扫描Spring的注解--&gt; &lt;context:component-scan base-package=&quot;cn.pj.ssj.dao.impl&quot;/&gt; &lt;context:component-scan base-package=&quot;cn.pj.ssj.service.impl&quot;/&gt; 2.3 dao层1234567891011121314@Repositorypublic class ProductDaoImpl implements IProductDao &#123; /** * PersistenceContext:持久上下文 * 上下文（一次请求（线程））只有一个EntityManager * xml配置的是LocalContainerEntityManagerFactoryBean，如果上下文中没有EntityManager，就创建 * 如果有，就直接拿 */ @PersistenceContext private EntityManager entityManager; @Override public void save(Product product) &#123; entityManager.persist(product); &#125; 2.4 事务管理器配置12345678&lt;!--配置事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt; &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt; &lt;/bean&gt; &lt;!--配置支持事务的注解,transaction-manager=&quot;transactionManager&quot;名字要与上面的一样，默认找transactionManager这个名字，这里不写也可以--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 2.5 service层 事务加在service层 propagation:事务传播机制 REQUIRED(默认配置):如果调用我的方法是有事务的，那么我们就使用同一个事务 REQUIRES_NEW: 不管谁调用我，我都会开一个自己的新事务 NEVER: 绝对不开事务，看到事务就报错给你看 SUPPORTS: 支持(调用我的方法有事务，就有,如果没有事务,就算了)123@Service@Transactional//表示这个类的所有方法加上事务public class ProductServiceImpl implements IProductService &#123; 查询不加事务12345678//表示不加事务 /** * */ @Transactional(readOnly = true,propagation = Propagation.SUPPORTS) public Product findOne(Serializable id) &#123; return productDao.findOne(id); &#125; 三. Spring+SpringMVC集成上面已经集成了JPA了，在此基础上集成SpringMVC 3.1 创建applicationContext-mvc.xml123456789101112&lt;!--扫描controller--&gt; &lt;context:component-scan base-package=&quot;cn.pj.ssj.controller&quot;/&gt; &lt;!--开启静态资源方法--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--扫描Springmvc注解支持--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 3.2 web.xml配置 注意：要用2.4版本以上的，否则不支持EL表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;!--spring配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--springmvc核心控制器配置--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--表示不论有没有编码，都会强制转--&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"Spring学习笔记(二)","slug":"Spring学习笔记-二","date":"2019-03-10T13:48:30.000Z","updated":"2019-03-10T14:10:48.393Z","comments":true,"path":"2019/03/10/Spring学习笔记-二/","link":"","permalink":"https://conjurermaple.github.io/2019/03/10/Spring学习笔记-二/","excerpt":"","text":"一. Spring的复习与导包1.1 什么是Spring 轻量级的DI/IOC与AOP的容器框架! BeanFactory与ApplicationContext的区别? ApplicationContext是BeanFactory的子接口，扩展了他的功能 ApplicationContext在加载xml时就会初始化bean，BeanFactory使用bean的时候才创建 1.2导包 Spring需要的包 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!--Spring的核心包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Context包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aop的包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--切面的一个包(织入)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring的测试包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;!--scope:范围,只能在test包中使用--&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--junit的测试支持--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 引入一些插件与资源 需要去读到java中的xml文件(默认不会编译) 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/test/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 二. 构造器注入 标签: constructor-arg 属性 index/name/type = 下标/名称/类型 属性 value/ref = 普通的值/引用 2.1 根据下标进行引入1234&lt;bean id=&quot;myBean&quot; class=&quot;cn.itsource._02_constructor.MyBean&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;小莫&quot; /&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;99&quot; /&gt;&lt;/bean&gt; 2.2 根据名称进行引入1234&lt;bean id=&quot;myBean&quot; class=&quot;cn.itsource._02_constructor.MyBean&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;小莫&quot; /&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;99&quot; /&gt;&lt;/bean&gt; 2.3 根据类型进行引入 不能出现重复类型 1234&lt;bean id=&quot;myBean&quot; class=&quot;cn.itsource._02_constructor.MyBean&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;小莫&quot; /&gt; &lt;constructor-arg type=&quot;java.lang.Integer&quot; value=&quot;99&quot; /&gt;&lt;/bean&gt; 2.4 自动进行引入 顺序是不允许修改的 1234&lt;bean id=&quot;myBean&quot; class=&quot;cn.itsource._02_constructor.MyBean&quot;&gt; &lt;constructor-arg value=&quot;小莫&quot; /&gt; &lt;constructor-arg value=&quot;99&quot; /&gt;&lt;/bean&gt; 2.5 在其它的bean的方式 外部bean是可以重复使用 1234567891011&lt;bean id=&quot;otherBean&quot; class=&quot;cn.itsource._02_constructor.OtherBean&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;myBean&quot; class=&quot;cn.itsource._02_constructor.MyBean&quot;&gt; &lt;!-- 外部bean --&gt; &lt;constructor-arg index=0 ref=&quot;otherBean&quot; /&gt; &lt;!-- 内部bean --&gt; &lt;constructor-arg index=&quot;2&quot;&gt; &lt;bean class=&quot;cn.itsource._02_constructor.OtherBean&quot; /&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 三. 属性注入3.1 普通属性 准备属性 12345// 简单属性private Long id;private String name;private Boolean sex;private BigDecimal salary; 配置的代码 1234&lt;property name=&quot;id&quot; value=&quot;1&quot; /&gt;&lt;property name=&quot;name&quot; value=&quot;王霸天&quot; /&gt;&lt;property name=&quot;sex&quot; value=&quot;true&quot;/&gt;&lt;property name=&quot;salary&quot; value=&quot;58&quot; /&gt; 3.2 集合 准备的属性 list与set(不允许重复) 关键的那个标签(list,set,array)写错(与声明的匹配不上)也可以用(但是不建议) 1234private List&lt;String&gt; list;private Set&lt;String&gt; set;private List&lt;OtherBean&gt; otherBeanList;private Set&lt;OtherBean&gt; otherBeanSet; 配置的代码 1234567891011121314151617181920212223242526272829303132333435&lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;abc&lt;/value&gt; &lt;value&gt;abc&lt;/value&gt; &lt;value&gt;123&lt;/value&gt; &lt;value&gt;321&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!--Set&lt;String&gt; set :无序,不重复--&gt;&lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;abc&lt;/value&gt; &lt;value&gt;abc&lt;/value&gt; &lt;value&gt;123&lt;/value&gt; &lt;value&gt;321&lt;/value&gt; &lt;/set&gt;&lt;/property&gt;&lt;!--List&lt;OtherBean&gt; otherBeanList--&gt;&lt;property name=&quot;otherBeanList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;otherBean&quot; /&gt; &lt;ref bean=&quot;otherBean&quot; /&gt; &lt;bean class=&quot;cn.itsource._03_di.OtherBean&quot; /&gt; &lt;bean class=&quot;cn.itsource._03_di.OtherBean&quot; /&gt; &lt;/list&gt;&lt;/property&gt;&lt;!--Set&lt;OtherBean&gt; otherBeanSet--&gt;&lt;property name=&quot;otherBeanSet&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;otherBean&quot; /&gt; &lt;ref bean=&quot;otherBean&quot; /&gt; &lt;bean class=&quot;cn.itsource._03_di.OtherBean&quot; /&gt; &lt;bean class=&quot;cn.itsource._03_di.OtherBean&quot; /&gt; &lt;/set&gt;&lt;/property&gt; 3.3 数组与properties 数组与properties都有两种写法(简写形式) properties的简写形式不支持中文 数组与properties123private String[] arrays;private Properties props1;private Properties props2; xml配置 1234567891011121314151617181920212223242526272829&lt;!--String[] arrays :标准写法 --&gt;&lt;!--&lt;property name=&quot;arrays&quot;&gt; &lt;array&gt; &lt;value&gt;abc&lt;/value&gt; &lt;value&gt;def&lt;/value&gt; &lt;value&gt;gf&lt;/value&gt; &lt;/array&gt;&lt;/property&gt;--&gt;&lt;!--String[] arrays :简写形式 (数组中每个值用,隔开)--&gt;&lt;property name=&quot;arrays&quot; value=&quot;abc,dfe,fd&quot; /&gt;&lt;!--Properties props1:标准写法--&gt;&lt;property name=&quot;props1&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql:///spring哈哈&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;admin&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;!--Properties props2:简写形式(不支持中文)--&gt;&lt;property name=&quot;props2&quot;&gt; &lt;value&gt; driver=com.mysql.jdbc.Driver url=jdbc:mysql:///spring哈哈 username=root &lt;/value&gt;&lt;/property&gt; 四. XML的自动注入(了解即可) 自动注入有两种方式 (类型与名称) 设置全局的自动注入 单独为某一个bean配置自动注入 五. 全注解(重要)5.1 扫描相应的包 注意:引入context的头 &lt;context:component-scan base-package=”cn.itsource._05_anno” /&gt; 5.2 在相应的类上加注解 Controller：控制层 Service：业务层 Repository：持久层 Component:组件(一个bean不知道在哪一层用这个) @Autowired:注入功能 5.3 如果出现多个bean类型一样怎么办？ 注解的bean有默认名称(类名【首字母小写】) 如 userDaoImpl 修改bean的名称 Component/Service/Repository/Controller(“名称”) 在注入bean的时候加上一个限定注解 1234@Autowired@Qualifier(&quot;userJPADaoImpl&quot;)//@Resource(name = &quot;userJDBCDao&quot;)private IUserDao userDao; 六 代理模式 分为静态与动态 Spring使用的是动态代码:JDK(接口)/CGLIB 动态代理的代码 1234567891011121314151617181920212223242526272829303132333435//通过JDK的方案创建一个动态代理对象呢？/** * java.lang.reflect:Proxy(代理)对象 * Foo Bar:张三，李四，王五 * ClassLoader loader ：类加载器(随便给它一个) Class&lt;?&gt;[] interfaces:接口(为什么这里是一个数组) InvocationHandler h :增强功能(自己实现) */IEmployeeService proxy = (IEmployeeService)Proxy.newProxyInstance( this.getClass().getClassLoader(), employeeService.getClass().getInterfaces(), new InvocationHandler() &#123; /** * @param proxy :代理对象(没有用) * @param method :执行的方法 * @param args :方法中的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; try &#123; txManager.begin(); //在这里面完成功能增强 //通过反射执行相应的方法 result = method.invoke(employeeService, args); txManager.commit(); &#125; catch (Exception e) &#123; txManager.rollback(); e.printStackTrace(); &#125; finally &#123; txManager.close(); &#125; return result; &#125; &#125;); 七. Spring的AOP7.1 XML版本 准备接口:IEmployeeService 12345public interface IEmployeeService &#123; void save(); void update(); void delete();&#125; 准备实现 EmployeeServiceImpl 1234567891011121314151617public class EmployeeServiceImpl implements IEmployeeService &#123; @Override public void save() &#123; System.out.println(&quot;送花给你....&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;EmployeeServiceImpl udpate..&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;EmployeeServiceImpl delete..&quot;); //int i = 1/0; &#125;&#125; 事务管理器(假) 12345678910111213141516171819202122232425262728293031323334353637public class TxManager &#123; public void begin()&#123; System.out.println(&quot;开启事务...&quot;); &#125; public void commit()&#123; System.out.println(&quot;提交事务...&quot;); &#125; public void rollback(Throwable e)&#123; System.out.println(&quot;回滚事务...,错误的原因:&quot;+e.getMessage()); &#125; public void close()&#123; System.out.println(&quot;关闭资源...&quot;); &#125; //搞了一个ProceedingJoinPoint（连接点对象） public void around(ProceedingJoinPoint joinPoint)&#123; System.out.println(joinPoint.getArgs()); //参数 System.out.println(joinPoint.getSignature()); //方法签名(这个方法的所有信息) System.out.println(joinPoint.getTarget().getClass()); //真实主题角色 System.out.println(joinPoint.getThis().getClass()); //代理主题角色 try &#123; begin(); joinPoint.proceed(); //执行对应的方法 commit(); &#125; catch (Throwable e) &#123; rollback(e); e.printStackTrace(); &#125; finally &#123; close(); &#125; &#125;&#125; 配置(关键) 引入aop的头 准备两个bean(EmployeeServiceImpl,TxManager) 如果有环绕通知,其它通知就不需要了 注意:何时,何地,做什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--真实主题角色--&gt; &lt;bean id=&quot;employeeService&quot; class=&quot;cn.itsource._08_xmlaop.EmployeeServiceImpl&quot; /&gt; &lt;!--准备一个事务--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;cn.itsource._08_xmlaop.TxManager&quot; /&gt; &lt;!--何时,何地,做什么事--&gt; &lt;!--代表要做一个AOP的配置--&gt; &lt;aop:config&gt; &lt;!-- 配置(定义)切点 在哪些类的哪些方法进行功能 id:切点名称(随便取) expression:表达式(最后定位都是方法) *:所有返回值 cn.itsource._08_xmlaop:对应的包 I*Service:以I开头,Service结尾的所有接口(所有实现接口的方法) *:所有方法 (..):所有参数 --&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.itsource._08_xmlaop.I*Service.*(..))&quot; /&gt; &lt;!-- 切面:由切点和增强组成 ref=&quot;txManager&quot; -&gt; 对应的增强类 --&gt; &lt;aop:aspect ref=&quot;txManager&quot;&gt; &lt;!-- aop:before:前置通知 何地:在哪些类的哪些方法中:pointcut 何时:在方法执行之前:before 做什么事:执行txManager这个bean中的begin方法 try &#123; //前置通知 result = method.invoke(employeeService, args); //后置通知 &#125; catch (Exception e) &#123; //异常通知 &#125; finally &#123; //最终通知 &#125; --&gt; &lt;!--&lt;aop:before method=&quot;begin&quot; pointcut-ref=&quot;pointcut&quot; /&gt;--&gt; &lt;!--后置通知--&gt; &lt;!--&lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pointcut&quot; /&gt;--&gt; &lt;!--异常通知 throwing这个错,方法中才可以获到(名字必需一致) --&gt; &lt;!--&lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pointcut&quot; throwing=&quot;e&quot; /&gt;--&gt; &lt;!--最终通知 --&gt; &lt;!--&lt;aop:after method=&quot;close&quot; pointcut-ref=&quot;pointcut&quot; /&gt;--&gt; &lt;!--环绕通知--&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pointcut&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 查看一下这个对象是否已经被代理 声明必需是接口 测试一下有异常与没有异常的区别 7.2 注解版 需要在相应的bean上加注解 配置包的扫描 所有的配置都是在TxManager加注解 xml配置 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--扫描包--&gt; &lt;context:component-scan base-package=&quot;cn.itsource._09_annoaop&quot; /&gt; &lt;!--支持切面的注解--&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; TxManager 切点的名字是方法名() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.itsource._09_annoaop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * @Aspect -&gt; &lt;aop:aspect ref=&quot;txManager&quot;&gt; */@Component@Aspectpublic class TxManager &#123; /** * 切点: * &lt;aop:pointcut id=&quot;pointcut()&quot; expression=&quot;execution(* cn.itsource._09_annoaop.I*Service.*(..))&quot; /&gt; */ @Pointcut(&quot;execution(* cn.itsource._09_annoaop.I*Service.*(..))&quot;) public void pointcut()&#123;&#125;// @Before(&quot;pointcut()&quot;) public void begin()&#123; System.out.println(&quot;开启事务...&quot;); &#125;// @AfterReturning(&quot;pointcut()&quot;) public void commit()&#123; System.out.println(&quot;提交事务...&quot;); &#125;// @AfterThrowing(pointcut = &quot;pointcut()&quot;,throwing = &quot;e&quot;) public void rollback(Throwable e)&#123; System.out.println(&quot;回滚事务...,错误的原因:&quot;+e.getMessage()); &#125;// @After(&quot;pointcut()&quot;) public void close()&#123; System.out.println(&quot;关闭资源...&quot;); &#125; //搞了一个ProceedingJoinPoint（连接点对象） @Around(&quot;pointcut()&quot;) public void around(ProceedingJoinPoint joinPoint)&#123; System.out.println(joinPoint.getArgs()); //参数 System.out.println(joinPoint.getSignature()); //方法签名(这个方法的所有信息) System.out.println(joinPoint.getTarget().getClass()); //真实主题角色 System.out.println(joinPoint.getThis().getClass()); //代理主题角色 try &#123; begin(); joinPoint.proceed(); //执行对应的方法 commit(); &#125; catch (Throwable e) &#123; rollback(e); e.printStackTrace(); &#125; finally &#123; close(); &#125; &#125;&#125;","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"JPA学习笔记(四)","slug":"JPA学习笔记-四","date":"2019-03-09T12:22:56.000Z","updated":"2019-03-10T13:46:54.557Z","comments":true,"path":"2019/03/09/JPA学习笔记-四/","link":"","permalink":"https://conjurermaple.github.io/2019/03/09/JPA学习笔记-四/","excerpt":"","text":"一. JPQL的认识与使用 JPA的查询语句(面向对象的) 关键字和SQL是一样的 使用的类和属性(区分大小写) 如果获取的是多个值 List&lt;Object[]&gt; 关连的法则(1.不写on 2.前面对象的别名.属性) 模糊查询JPQL中写? , 设置值 %name% 二. JPA的分页 支持所有数据库（根据方言类决定） 设置从第几条数据开始 query.setFirstResult(0) 设置每页条数 query.setMaxResults(5) 12345678910EntityManager entityManager = JpaUtil.getEntityManager(); //query:查询对象 Query query = entityManager.createQuery(&quot;from Employee&quot;); //query.setFirstResult(5); //query.setMaxResults(5); query.setFirstResult(15).setMaxResults(5); List&lt;Employee&gt; list = query.getResultList(); list.forEach(e -&gt; System.out.println(e)); entityManager.close(); 拿出到总条数 如果确定有且只有一个数据,使用 getSingleResult 类型是Long(hibernate3.X是Integer) 12345678910EntityManager entityManager = JpaUtil.getEntityManager();//query:查询对象// 这条SQL百之百确认只会查到一个数据Query query = entityManager.createQuery(&quot;select count(o) from Employee o&quot;);//Single:单个 这里拿到的是Long类型// hibernate3.X的版本都使用的IntegerLong count = (Long)query.getSingleResult();System.out.println(count);entityManager.close(); 三. 原生SQL的操作 执行SQL,但是需要手动封装对象 entityManager.createNativeQuery(sql) 12345678910 String sql = &quot;select * from employee&quot;;EntityManager entityManager = JpaUtil.getEntityManager();//query:查询对象 Native:原生Query query = entityManager.createNativeQuery(sql);List&lt;Object[]&gt; list = query.getResultList();list.forEach(objs -&gt; &#123; System.out.println(Arrays.asList(objs));&#125;);entityManager.close(); 执行SQL,但是需要自动封装对象 entityManager.createNativeQuery(sql,Employee.class);123456789String sql = &quot;select * from employee&quot;; EntityManager entityManager = JpaUtil.getEntityManager(); //query:查询对象 Native:原生 Query query = entityManager.createNativeQuery(sql,Employee.class); List&lt;Employee&gt; list = query.getResultList(); list.forEach(e -&gt; System.out.println(e)); entityManager.close(); 四. 事务隔离与锁 一定要自己去控制中间表的表名与列名 正常操作都没有问题(尽量不要使用级联) 双向保证表名列名是一致的 1234567891011/** * @JoinTable:对中间表进行设置 * name = &quot;t_user_role&quot;:中间表的名称 * joinColumns = @JoinColumn(name = &quot;user_id&quot;):修改当前表对应的列名 * inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;):对面那张表的列名 */@ManyToMany@JoinTable(name = &quot;t_user_role&quot; ,joinColumns = @JoinColumn(name = &quot;user_id&quot;) ,inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;))private List&lt;Role&gt; roles = new ArrayList&lt;&gt;(); 五. 一对一(了解) 共享主键(扩展性不强,不建议使用) 唯一外键(扩展性强,建议使用) 外键在哪边,哪边就是从表 QQ:主表12345678910@Entitypublic class QQ &#123; @Id @GeneratedValue private Long id; private String number; // 一对一,一个qq号码对应一个qq空间 @OneToOne(mappedBy=&quot;qq&quot;) private QQZone zone;｝ QQZone:从表 12345678910111213@Entitypublic class QQZone &#123; @Id @GeneratedValue private Long id; private String name; // 一对一,一个qq空间输入一个qq号码 // 默认值optional = true表示qq_id可以为空;反之。。。 @OneToOne(optional = false) // unique=true确保了一对一关系 @JoinColumn(name = &quot;qq_id&quot;, unique = true) private QQ qq;｝ 六. 注意 单向多对一,一对多,双向多对一,一对多,表结构完成一样 单向一对多性能差(不用) 声明的时候都用接口 集合先new出来(以免以后代码麻烦) JPA，集合默认懒加载 想要性能好，先保存一方后保存多方 先配置单向(业务需要再配置双向) 8.不要toString()，- 互相调用容易内存溢出","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"JPA学习笔记(三)","slug":"JPA学习笔记-三","date":"2019-03-07T12:30:15.000Z","updated":"2019-03-07T12:38:05.262Z","comments":true,"path":"2019/03/07/JPA学习笔记-三/","link":"","permalink":"https://conjurermaple.github.io/2019/03/07/JPA学习笔记-三/","excerpt":"","text":"一. 单向一对多 性能非常差,不建议使用 如果要使用，建议使用双向的多对一，一对多 代码配置 必需使用接口声明 可以使用List(有序允许重复)或者Set 一定要指定外键(否则会出现中间表)123@OneToMany@JoinColumn(name = &quot;dir_id &quot;)private List&lt;Product&gt; products = new ArrayList&lt;&gt;(); 二. 双向多对一，一对多 双向配置的表结构和单向是完全一样的 尽量使用多方来维护关系(性能好) 外键在哪边,哪边就是多方(也方便维护) Prdocut(多方)12345678910111213 @Entity@Table(name = &quot;product&quot;)public class Product &#123; ... /** * 多个产品对应一个产品类型 * 默认的名称就dir_id */ @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name=&quot;dir_id&quot;) private ProductDir dir; ...&#125; PrdocutDir(一方) 1234567891011121314@Entity@Table(name = &quot;productdir&quot;)public class ProductDir &#123; ... /** * 确定外键关连的名称叫:dir_id * 保证维护关系的列是同一列 * mappedBy = &quot;dir&quot; :映射的关系交给Product类中的dir的属性去维护 * 放弃了关系维护 */ @OneToMany(mappedBy = &quot;dir&quot;) private List&lt;Product&gt; products = new ArrayList&lt;&gt;(); ...&#125; 三. 级联 级联很危险,不要随便使用 组合关系(单据)必需使用级联 要使用就是使用最强级联: cascade = CascadeType.ALL,orphanRemoval = true 代码配置 1234567891011121314151617181920@Entity@Table(name = &quot;productdir&quot;)public class ProductDir &#123; ... /** * 确定外键关连的名称叫:dir_id * 保证维护关系的列是同一列 * mappedBy = &quot;dir&quot; :映射的关系交给Product类中的dir的属性去维护 * 放弃了关系维护 * cascade:级联 * CascadeType.PERSIST:级联保存(一人得道,鸡狗升天) * CascadeType.MERGE:级联修改（荣辱与共） * CascadeType.REMOVE:级联删除 (生死与共) * CascadeType.ALL：级联增删改 * orphanRemoval：孤儿删除 */ @OneToMany(mappedBy = &quot;dir&quot;,cascade = CascadeType.ALL,orphanRemoval = true) private List&lt;Product&gt; products = new ArrayList&lt;&gt;(); ...&#125; 四. 多对多 一定要自己去控制中间表的表名与列名 正常操作都没有问题(尽量不要使用级联) 双向保证表名列名是一致的 1234567891011/** * @JoinTable:对中间表进行设置 * name = &quot;t_user_role&quot;:中间表的名称 * joinColumns = @JoinColumn(name = &quot;user_id&quot;):修改当前表对应的列名 * inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;):对面那张表的列名 */@ManyToMany@JoinTable(name = &quot;t_user_role&quot; ,joinColumns = @JoinColumn(name = &quot;user_id&quot;) ,inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;))private List&lt;Role&gt; roles = new ArrayList&lt;&gt;(); 五. 一对一(了解) 共享主键(扩展性不强,不建议使用) 唯一外键(扩展性强,建议使用) 外键在哪边,哪边就是从表 QQ：主表 12345678910@Entitypublic class QQ &#123; @Id @GeneratedValue private Long id; private String number; // 一对一,一个qq号码对应一个qq空间 @OneToOne(mappedBy=&quot;qq&quot;) private QQZone zone;｝ QQZone:从表 12345678910111213@Entitypublic class QQZone &#123; @Id @GeneratedValue private Long id; private String name; // 一对一,一个qq空间输入一个qq号码 // 默认值optional = true表示qq_id可以为空;反之。。。 @OneToOne(optional = false) // unique=true确保了一对一关系 @JoinColumn(name = &quot;qq_id&quot;, unique = true) private QQ qq;｝ 六. 注意点 单向多对一,一对多,双向多对一,一对多,表结构完成一样 单向一对多性能差(不用) 声明的时候都用接口 集合先new出来(以免以后代码麻烦) JPA，集合默认懒加载 想要性能好，先保存一方后多方 先配置单向(业务需要再配置双向) 不要在toString()相互打印，互相调用容易内存溢出","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"JPA学习笔记(二)","slug":"JPA学习笔记-二","date":"2019-03-06T06:47:12.000Z","updated":"2019-03-06T07:02:32.478Z","comments":true,"path":"2019/03/06/JPA学习笔记-二/","link":"","permalink":"https://conjurermaple.github.io/2019/03/06/JPA学习笔记-二/","excerpt":"","text":"一. 主键生成策略1.1 主键设置两种方式 代理主键（没有业务含义，建议使用） 自然主键（有业务含义：手机号，身份证。。） 1.2 四种主键生成策略123@Id@GeneratedValue(strategy = GenerationType.IDENTITY/SEQUENCE/AUTO/TABLE)private Long id; 1.2.1 IDENTITY:自增策略 必须是数字 数据库必需支持这种策略 MySQL, SQL Server, DB2, Derby, Sybase, PostgreSQL支持 效率高 1.2.2 SEQUENCE:序列策略 必须是数字 数据库必需支持这种策略 Oracle、PostgreSQL、DB2支持 效率高 1.2.3 AUTO:自动(默认) 默认就是它 根据方言确定策略(IDENTITY,SEQUENCE) 1.2.4 Table:表策略 性能比较低 兼容所有数据库 模拟序列的方式 二. 对应的状态 临时状态（瞬时状态）,持久状态,删除状态，游离状态 临时:刚创建，和EntityManager没有关系 持久:对象和EntityManager发生关系(一级缓存中) 删除状态(jpa特有的),执行remove(计划删除),将持久状态改为删除状态 游离:对象和EntityManager解除关系 2.1 脏数据更新 一个持久化状态的对象，如果被修改,就会在提交事务的时候被修改 2.2 持久化对象的OID不允许修改 n-to-n的错 dentifier of an instance of cn.itsource._02_state.Employee was altered from 1 to 2 三. 对象之间的关系3.1 依赖关系 类与类之间的依赖关系 controller依赖于service ，service依赖于dao 3.2 关联关系3.2.1 多重性 一对一 (共享主键,唯一的外键【建议】) 多对一 (有外键关系,外键在哪边，哪边就是多方) 一对多 (同上) 多对多 (中间表) 3.2.2 导航性 单向与双向 只用于类(对象)，和表没有关系 3.2.3 聚合关系就是双向的多对一，一对多 3.2.4 组合关系就是强聚合(整体与部分不可分割) 四. 单向多对一的配置 ProductDir.java1234567891011//产品类别@Entity@Table(name = &quot;t_productdir&quot;)public class ProductDir &#123; @Id @GeneratedValue private Long id; private String name; //省略getter,setter&#125; Product.java12345678910111213141516//产品@Entity@Table(name = &quot;t_product&quot;)public class Product &#123; @Id @GeneratedValue private Long id; private String name; //外键在哪边，哪边就是多方 @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name=&quot;dir_id&quot;) private ProductDir dir; //省略getter,setter&#125; 4.1 注意点 先保存一方，再保存多方(性能更高) 可以配置懒加载提高性能 no-session,会话(entityManager)关闭还去拿出数据 五. 二级缓存5.1 两个命中 一级缓存命中:同一个EntityManagerFactory，同一个EntityManager,同一个OID 二级缓存命中:同一个EntityManagerFactory，不同EntityManager,同一个OID 5.2 二级缓存的使用场景 读取大于修改； 对数据要有独享控制,数据不会被第三方修改； 可以容忍出现无效数据,非关键数据（不是财务数据等） 数据量不能超过内存容量,数据量特别巨大，此时不适合于二级缓存(钝化)","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"JPA学习笔记(一)","slug":"JPA学习笔记-一","date":"2019-03-04T13:04:35.000Z","updated":"2019-03-04T13:46:48.936Z","comments":true,"path":"2019/03/04/JPA学习笔记-一/","link":"","permalink":"https://conjurermaple.github.io/2019/03/04/JPA学习笔记-一/","excerpt":"","text":"一.JPA认识1.1 什么是JPA JPA:(Java Persistence API) ORM的规范 JPA是规范,Hibernate是它的实现(不唯一,但最好) 最底层的操作还是JDBC(引入驱动包) 1.2 什么是ORM o(对象,java面向对象) r(关系,关系型数据库) m(映射) 1.3 JPA与JDBC的区别 JPA(hibernate)的底层还是JDBC JPA开发效率高(JPA代码简单) JPA运行效率低(jdbc高:更接近低层) JPA兼容各种数据库(方便移植) JPA有内置缓存(性能在一定程度上还是有优化) 具体的东西请百度 二.HelloWorld2.1 创建maven项目2.2 pom.xml 导包(hibernate核心包,JPA支持包,驱动包,测试包) JDK1.8插件配置支持 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itsource&lt;/groupId&gt; &lt;artifactId&gt;jpademo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;jpaday01&lt;/module&gt; &lt;/modules&gt; &lt;!--导包:hibernate的包 ,hibernate对于JPA的支持包,数据库驱动包,junit测试包--&gt; &lt;dependencies&gt; &lt;!--hibernate的核心包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.8.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--hiberante对于jpa的支持包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;4.3.8.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--设置咱们项目的JDK版本--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.3 引入persistence.xml2.3.1 使用工具生成 META-INF\\persistence.xml 也可以手动创建 调整结构如下 persistence.xml 1234567891011121314151617181920212223242526272829303132333435 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence xmlns=\"http://java.sun.com/xml/ns/persistence\" version=\"2.0\"&gt; &lt;!-- 咱们这个配置是要连接数据库的(jpa支持咱们连接多个数据库) persistence-unit:持久化单元(可能有多个，每一个对应一个数据库) name:取个名称(随便取) transaction(事务,同生共死)-type(类型) RESOURCE_LOCAL：本地的事务 JTA: 分布式系统要使用的事务 基本的数据库连接配置(四大金刚) properties:属性(所有属性都可以在下面的文件中找到) resources\\源码包\\hibernate-release-4.3.8.Final\\project\\etc\\hibernate.properties --&gt; &lt;persistence-unit name=\"cn.itsource.jpa\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;properties&gt; &lt;!--连接数据库的四个基本属性--&gt; &lt;property name=\"hibernate.connection.driver_class\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"hibernate.connection.url\" value=\"jdbc:mysql:///jpa\" /&gt; &lt;property name=\"hibernate.connection.username\" value=\"root\" /&gt; &lt;property name=\"hibernate.connection.password\" value=\"root\" /&gt; &lt;!-- 配置方言(数据库兼容):你要操作的是什么数据库,根据不同的方言拼接不同的SQL InnoDB:支持事务,支持外键 MyISAM:不支持事务，不支持外键(属性高) --&gt; &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.MySQLDialect\" /&gt; &lt;!--配置建表策略(自动化帮我们创建相应的表)--&gt; &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"create\" /&gt; &lt;!--可以看到SQL的展示--&gt; &lt;property name=\"hibernate.show_sql\" value=\"true\" /&gt; &lt;!--可以看到SQL的展示(漂亮一点)--&gt; &lt;!--&lt;property name=\"hibernate.format_sql\" value=\"true\" /&gt;--&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 2.4准备domain对象123456789101112131415161718192021222324252627282930//告诉JPA:这个类是要做实体化的/** * @Entity:我是一个实体类，JPA快来管我 * @Table(name = \"t_employee\"):我和哪些张是有关系的 * 如果不写，他就认为你有一个表叫:Employee */import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name = \"t_employee\")public class Employee &#123; /** * @Id:代表我是一个主键 * @GeneratedValue:我们认为主键是自增的 */ @Id @GeneratedValue private Long id; private String name; private String password; //getter,setter省略&#125; 2.5 基本功能测试 Persistence -&gt; EntityManagerFactory -&gt; EntityManager -&gt; crud EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(“jpa”); EntityManager entityManager = entityManagerFactory.createEntityManager(); 注意点:增删改需要事务 EntityManager可以拿到一个事务 1234567891011121314151617/** * 在JPA中,所以增删改都需要我们去提交事务 *///拿到EntityManagerFactory(传入持久化单元的名称)EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(\"cn.itsource.jpa\");//拿出到实体管理对象EntityManager entityManager = entityManagerFactory.createEntityManager();//拿出一个事务 EntityManager里面有一个事务(只能拿到一个事务)//开始事务entityManager.getTransaction().begin();//persist:持久化(保存一条数据)entityManager.persist(employee);//提交事务entityManager.getTransaction().commit();//关闭资源entityManager.close();entityManagerFactory.close(); 三. CRUD 工具类 1234567891011121314151617181920//帮咱们拿到一个EntityManager对象public class JpaUtil &#123; private static EntityManagerFactory factory; //加载时运行，且只运行一次 static &#123; try &#123; factory = Persistence.createEntityManagerFactory(\"cn.itsource.jpa\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //直接拿到EntityManager对象 public static EntityManager getEntityManager()&#123; return factory.createEntityManager(); &#125;&#125; 3.1 添加 entityManager.persist(employee); 3.2 修改 entityManager.merge(employee); 3.3 删除 先查询，再判断，最后删除12345 Employee employee = entityManager.find(Employee.class, id);if(employee!=null) &#123; //这里要求咱们传一个对象进去 entityManager.remove(employee);&#125; 3.4 查询一条数据 传类型与id entityManager.find(Employee.class,id); 3.5 查询所有 query对象(entityManager创建) jpql:面向对象的查询语言 12345678910entityManager = JpaUtil.getEntityManager();//使用查询对象，写JPQL：像SQL,但是更加简单(面向对象)//1.准备JPQL 不要写* ,from后面是一个类//String jpql = \"select o from cn.itsource.jpa.domain.Employee o\";// String jpql = \"select o from Employee o\";String jpql = \"from Employee\";//2.根据JPQL拿到查询对象Query query = entityManager.createQuery(jpql);//3.返回所有数据return query.getResultList(); 四. 建表策略例：1&lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot;/&gt; 4.1 create-drop 先删除-&gt; 再创建 -&gt; 用完(EntityManagerFactory关闭)再删(测试) 4.2 create 先删除-&gt; 再创建(测试) 4.3 updates 没有表就创建，有就修改 修改字段只增不减(不改类型) 4.4 validate 验证功能(只验证domain中写好的属性),如果domain类没有，数据库中有这个字段，不会验证 五. 重要API认识5.1 Persistence 解析相应的核心配置文件 创建EntityManagerFactory对象 5.2 EntityManagerFactory 重量级(连接池,二级缓存,所有实体关系，预编译的SQL/JPQL) 线程安全 (1:1:1) 1个应用程序，1个EntityManagerFactory，1个数据库 创建 EntityManager对象 5.3 EntityManager 轻量级(连接对象,一级缓存) 线程不安全 完成CRUD 什么是一级缓存命中?同一个EntityManagerFactory,同一个EntityManager,同一个OID OID是什么样子的? 类的全限定名#id 如cn.itsource.jpa.domain.Employee#1 5.4 EntityTransaction例：1&lt;persistence-unit name=&quot;jpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; EntityManager只有这一个事务 如果多个系统/多个数据库 -&gt; transaction-type=”JTA” 六. 映射细节@Column12345 name = \"username\"：对应的列名 length=2 :长度 nullable = false:该字符不能为空 unique = true：唯一@Column(name = \"username\",length = 20,nullable = false,unique = true) @Lob 大文本(装很多数据) Transient 临时属性(JPA不会管理这个属性) Temporal TemporalType.TIMESTAMP:年月日,时分秒 TemporalType.DATE:年月日 TemporalType.TIME:时分秒","categories":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/categories/框架篇/"}],"tags":[{"name":"框架篇","slug":"框架篇","permalink":"https://conjurermaple.github.io/tags/框架篇/"}]},{"title":"EasyUI学习笔记（二）——综合案例","slug":"EasyUI学习笔记（二）——综合案例","date":"2019-03-01T03:04:20.000Z","updated":"2019-03-01T03:42:50.177Z","comments":true,"path":"2019/03/01/EasyUI学习笔记（二）——综合案例/","link":"","permalink":"https://conjurermaple.github.io/2019/03/01/EasyUI学习笔记（二）——综合案例/","excerpt":"","text":"EasyUI常用组件Tabs选项卡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;!-- easyui的样式主题文件 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"easyui/themes/default/easyui.css\"&gt;&lt;!-- easyui的系统图标--&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"easyui/themes/icon.css\"&gt;&lt;!-- easyui依赖的jquery库--&gt; &lt;script type=\"text/javascript\" src=\"easyui/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- easyui的插件库--&gt; &lt;script type=\"text/javascript\" src=\"easyui/jquery.easyui.min.js\"&gt;&lt;/script&gt;&lt;!-- easyui的汉化包 --&gt;&lt;script type=\"text/javascript\" src=\"easyui/locale/easyui-lang-zh_CN.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"tt\" class=\"easyui-tabs\" style=\"width:500px;height:250px;\" tools=\"#tab-tools\"&gt; &lt;div title=\"Tab1\" style=\"padding:20px;display:none;\"&gt; tab1 &lt;/div&gt; &lt;div title=\"Tab2\" data-options=\"closable:true\" style=\"overflow:auto;padding:20px;display:none;\"&gt; tab2 &lt;/div&gt; &lt;div title=\"Tab3\" data-options=\"iconCls:'icon-reload',closable:true\" style=\"padding:20px;display:none;\"&gt; tab3 &lt;/div&gt; &lt;/div&gt; &lt;div id=\"tab-tools\"&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" data-options=\"plain:true,iconCls:'icon-add'\" onclick=\"addPanel()\"&gt;&lt;/a&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" data-options=\"plain:true,iconCls:'icon-remove'\" onclick=\"removePanel()\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function addPanel() &#123; //调用tabs的add方法增加选项卡 $(\"#tt\").tabs('add',&#123; title: '新选项卡面板', selected: true, closable:true &#125;); &#125; function removePanel() &#123; //调用tabs的getSelected方法获取选中的那一行 var tab = $('#tt').tabs('getSelected'); //获取选中那行的索引 var index = $('#tt').tabs('getTabIndex',tab); //通过索引来关闭选项卡 $(\"#tt\").tabs('close',index); &#125; &lt;/script&gt;&lt;/body&gt; messager(消息窗口) 12345678910111213141516171819202122 &lt;script type=\"text/javascript\"&gt; //显示方法 $.messager.show(&#123; title:'我的消息', msg:'消息将在5秒后关闭。', timeout:5000, showType:'slide'&#125;); /* $.messager.progress(); 进度条 $.messager.alert('我的消息','这是一个提示信息！','info'); */ $.messager.confirm('确认对话框', '您想要退出该系统吗？', function(r)&#123; if (r)&#123; // 退出操作; alert(\"退出系统\"); &#125;&#125;); &lt;/script&gt; form（表单）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 &lt;body&gt; &lt;div style=\"margin:20px 0;\"&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" onclick=\"loadLocal()\"&gt;加载本地数据&lt;/a&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" onclick=\"loadRemote()\"&gt;加载远程数据&lt;/a&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" onclick=\"clearForm()\"&gt;清空表单&lt;/a&gt; &lt;/div&gt; &lt;div id=\"bs\"&gt; &lt;a class=\"easyui-linkbutton\" iconCls=\"icon-ok\" onclick=\"$('#ff').submit();\"&gt;提交[方式一]&lt;/a&gt; &lt;a class=\"easyui-linkbutton\" iconCls=\"icon-ok\" id=\"submitBtn\"&gt;提交[方式二]&lt;/a&gt; &lt;/div&gt;&lt;div id=\"Employee Dialog\" class=\"easyui-dialog\" style=\"width: 300px; height: 300px; padding: 10px\" data-options=\"title:'用户信息',buttons:'#bs'\"&gt;&lt;form id=\"ff\" method=\"post\"&gt; &lt;table cellpadding=\"5\"&gt; &lt;tr&gt; &lt;td&gt;ID:&lt;/td&gt; &lt;td&gt;&lt;input class=\"easyui-textbox\" type=\"text\" name=\"id\" data-options=\"required:true\"&gt;&lt;/input&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Name:&lt;/td&gt; &lt;td&gt;&lt;input class=\"easyui-textbox\" type=\"text\" name=\"name\" data-options=\"required:true\"&gt;&lt;/input&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function loadLocal()&#123; $(\"#ff\").form('load',&#123; \"id\":1, \"name\":\"技术部\" &#125;); &#125;; function loadRemote() &#123; $(\"#ff\").form('load','dept.json'); &#125; function clearForm() &#123; $(\"#ff\").form('clear'); &#125; //定义表单提交的信息 $(\"#ff\").form(&#123; url:'', success:function(data) &#123; &#125; &#125;); //如果标签里没写submit(),就要手动提交 $('#ff').form('submit', &#123; url: ..., onSubmit: function()&#123; &#125;, success: function()&#123; &#125;&#125;); &lt;/script&gt;&lt;/body&gt; datagrid(数据表格)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt;&lt;!-- datagrid是table 要在th上设置field字段：来匹配数据 class=\"easyui-datagrid\" toolbar:'#tb'：工具栏 fitColumns:true表头自动填充网格，要配合th上的width使用 rownumbers:true：显示行号 striped:true 隔行换色，斑马线 pagination:true：分页 --&gt; &lt;table id=\"tt\" title=\"员工管理\" class=\"easyui-datagrid\" data-options=\"toolbar:'#tb',fitColumns:true,rownumbers:true,singleSelect:true,striped:true,pagination:true\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;!-- &lt;th field=\"id\" width=\"50\" hidden=\"true\"&gt;ID&lt;/th&gt; --&gt; &lt;th field=\"id\" width=\"50\"&gt;ID&lt;/th&gt; &lt;th field=\"name\" width=\"50\"&gt;姓名&lt;/th&gt; &lt;th field=\"age\" width=\"50\"&gt;年龄&lt;/th&gt; &lt;th field=\"dept\" width=\"50\"&gt;部门&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;div id=\"tb\"&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" iconCls=\"icon-add\" plain=\"true\" onclick=\"newEmployee ()\"&gt;添加员工&lt;/a&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" iconCls=\"icon-edit\" plain=\"true\" onclick=\"editEmployee ()\"&gt;编辑员工&lt;/a&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" iconCls=\"icon-remove\" plain=\"true\" onclick=\"destroyEmployee ()\"&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; //请求数据 $(\"#tt\").datagrid(&#123; data:[ &#123; id:123, name:'zs', age:20, dept:'开发部' &#125;, &#123; id:456, name:'ls', age:30, dept:'开发部' &#125; ] &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; EasyUI布局（layout）1234567891011121314151617&lt;!-- easyui-layout 布局容器 fit=\"true\" : 撑满整个页面 或者直接使用body作为布局容器. &lt;body class=\"easyui-layout\"&gt; &lt;/body&gt;--&gt; &lt;!-- 共5个区域,使用region来设置,值:north,south,west,east,center split : true 可拖动大小 collapsible : false 取消折叠按钮 --&gt;&lt;body class=\"easyui-layout\"&gt; &lt;div data-options=\"region:'north',title:'North Title',split:true\" style=\"height:100px;\"&gt;&lt;/div&gt; &lt;div data-options=\"region:'south',title:'South Title',split:true\" style=\"height:100px;\"&gt;&lt;/div&gt; &lt;div data-options=\"region:'east',iconCls:'icon-reload',title:'East',split:true\" style=\"width:100px;\"&gt;&lt;/div&gt; &lt;div data-options=\"region:'west',title:'West',split:true\" style=\"width:100px;\"&gt;&lt;/div&gt; &lt;div data-options=\"region:'center',title:'center title'\" style=\"padding:5px;background:#eee;\"&gt;&lt;/div&gt; &lt;/body&gt; 综合案例（crud）menuTree.json12345678910111213141516171819202122232425262728293031323334353637[&#123; \"id\": 1, \"text\": \"系统管理\", \"state\": \"open\", \"children\": [&#123; \"id\": 12, \"text\": \"部门管理\", \"iconCls\":\"icon-lock\", \"url\":\"/department/index\" &#125;,&#123; \"id\": 11, \"text\": \"员工管理\", \"iconCls\":\"icon-man\", \"url\":\"/emp_list.html\" &#125;]&#125;,&#123; \"id\": 1, \"text\": \"基本信息\", \"state\": \"closed\", \"children\": [&#123; \"id\": 11, \"text\": \"菜单管理\", \"iconCls\":\"icon-man\", \"url\":\"/user.action\" &#125;,&#123; \"id\": 12, \"text\": \"角色管理\", \"iconCls\":\"icon-man\", \"url\":\"/customer/index\" &#125;,&#123; \"id\": 12, \"text\": \"资源管理\", \"iconCls\":\"icon-man\", \"url\":\"/06_panel.jsp\" &#125; ]&#125;] index.html1234567891011121314151617181920212223242526272829303132&lt;body class=\"easyui-layout\"&gt; &lt;div data-options=\"region:'north',split:true\" style=\"height:60px;\"&gt;&lt;/div&gt; &lt;div data-options=\"region:'south',split:true\" style=\"height:60px;\"&gt;&lt;/div&gt; &lt;div id=\"tt\" data-options=\"region:'west',title:'West',split:false,collapsible:false\" style=\"width:160px;\"&gt;&lt;/div&gt; &lt;div id=\"mainUI\" class=\"easyui-tabs\" data-options=\"region:'center'\" style=\"background:#eee;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $('#tt').tree(&#123; url:'menuTree.json', onClick:function(node) &#123; var title = node.text;//菜单的内容 //console.log(title) var url = node.url; //调用tabs的exists方法根据title判断是否存在 var exist = $(\"#mainUI\").tabs('exists',title); if (exist) &#123; //如果存在就选中他 $(\"#mainUI\").tabs('select',title); &#125; else &#123; //如果不存在就新增 $(\"#mainUI\").tabs('add',&#123; title: title, selected: true, closable:true, content:'&lt;iframe frameborder=\"0\" style=\"width: 100%;height: 100%\" src=\"'+url+'\"&gt;&lt;/iframe&gt;' &#125;); &#125; &#125; &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; json文件success.json1&#123;\"success\":true&#125; employee.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&#123; \"total\": 139, \"rows\": [ &#123; \"id\": 1, \"username\": \"admin\", \"password\": \"48d05cc43f3bfe2510394e8dfcef919a\", \"email\": \"admin@163.com\", \"age\": 34, \"headImage\": \"/images/head/1.gif\", \"department\": &#123; \"id\": 1, \"name\": \"IT部\" &#125; &#125;, &#123; \"id\": 2, \"username\": \"roleAdmin\", \"password\": \"d563ad18fb8e2067eaee76ca27f3e8a3\", \"email\": \"roleAdmin@163.cn\", \"age\": 25, \"headImage\": \"/images/head/lvlv.jpg\", \"department\": &#123; \"id\": 1, \"name\": \"IT部\" &#125; &#125;, &#123; \"id\": 3, \"username\": \"admin1\", \"password\": \"6a4876827226fb87ffeb78edb2b1e7ad\", \"email\": \"amdin1@163.cn\", \"age\": 25, \"headImage\": \"/images/head/avatar2.png\", \"department\": null &#125;, &#123; \"id\": 4, \"username\": \"admin2\", \"password\": \"d157d747dc2f6740e81ca9d84b669272\", \"email\": \"amdin2@163.cn\", \"age\": 25, \"department\": &#123; \"id\": 2, \"name\": \"采购部\" &#125; &#125;, &#123; \"id\": 5, \"username\": \"admin3\", \"password\": \"89335a5f0fdd015113e9acf90727cdce\", \"email\": \"amdin3@163.cn\", \"age\": 25, \"headImage\": \"/images/head/avatar3.png\", \"department\": &#123; \"id\": 1, \"name\": \"IT部\" &#125; &#125;, &#123; \"id\": 6, \"username\": \"admin4\", \"password\": \"12e4dc60e1813184b3e4552dedd7bf9b\", \"email\": \"amdin4@163.cn\", \"age\": 25, \"headImage\": \"/images/head/avatar3.png\", \"department\": &#123; \"id\": 3, \"name\": \"销售部\" &#125; &#125;, &#123; \"id\": 7, \"username\": \"admin5\", \"password\": \"02f9b7f759b5654d421c0ce458d16c28\", \"email\": \"amdin5@163.cn\", \"age\": 25, \"headImage\": \"/images/head/avatar3.png\", \"department\": &#123; \"id\": 1, \"name\": \"IT部\" &#125; &#125;, &#123; \"id\": 8, \"username\": \"admin6\", \"password\": \"138e943e0987d1fff7a4c367deedd4e3\", \"email\": \"amdin6@163.cn\", \"age\": 25, \"headImage\": \"/images/head/avatar3.png\", \"department\": &#123; \"id\": 2, \"name\": \"采购部\" &#125; &#125;, &#123; \"id\": 9, \"username\": \"admin7\", \"password\": \"53bf9cd2cb250a9d82c3260b6d398d73\", \"email\": \"amdin7@163.cn\", \"age\": 25, \"department\": &#123; \"id\": 2, \"name\": \"采购部\" &#125; &#125;, &#123; \"id\": 10, \"username\": \"admin8\", \"password\": \"f6bd6e8ca007216fef1ddd9652e5d42f\", \"email\": \"amdin8@163.cn\", \"age\": 25, \"headImage\": \"/images/head/avatar3.png\", \"department\": &#123; \"id\": 1, \"name\": \"IT部\" &#125; &#125; ]&#125; depts.json1234567891011121314[ &#123; \"id\":1, \"name\":\"IT部\" &#125;, &#123; \"id\":2, \"name\":\"采购部\" &#125;, &#123; \"id\":3, \"name\":\"销售部\" &#125;] emp_list.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269 &lt;!-- easyui的样式主题文件 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"easyui/themes/default/easyui.css\"&gt;&lt;!-- easyui的系统图标--&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"easyui/themes/icon.css\"&gt;&lt;!-- easyui依赖的jquery库--&gt; &lt;script type=\"text/javascript\" src=\"easyui/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- easyui的插件库--&gt; &lt;script type=\"text/javascript\" src=\"easyui/jquery.easyui.min.js\"&gt;&lt;/script&gt;&lt;!-- easyui的汉化包 --&gt;&lt;script type=\"text/javascript\" src=\"easyui/locale/easyui-lang-zh_CN.js\"&gt;&lt;/script&gt; &lt;!-- 验证框架以下两个js文件有先后顺序 --&gt;&lt;script type=\"text/javascript\" src=\"easyui/plugin/jquery.jdirk.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"easyui/plugin/validatebox/jeasyui.extensions.validatebox.css\"&gt;&lt;script type=\"text/javascript\" src=\"easyui/plugin/validatebox/jeasyui.extensions.validatebox.rules.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=\"tt\" class=\"easyui-datagrid\" data-options=\"toolbar:'#tb',fitColumns:true,singleSelect:true,striped:true,pagination:true\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;!-- &lt;th field=\"id\" width=\"50\" hidden=\"true\"&gt;ID&lt;/th&gt; --&gt; &lt;th field=\"id\" width=\"15\"&gt;ID&lt;/th&gt; &lt;th field=\"username\" width=\"20\"&gt;姓名&lt;/th&gt; &lt;th field=\"password\" width=\"50\"&gt;密码&lt;/th&gt; &lt;th field=\"email\" width=\"40\"&gt;邮箱&lt;/th&gt;&lt;!-- field要与json的字段对应上 通过formatter来执行方法 --&gt; &lt;th field=\"age\" width=\"10\" formatter=\"ageFormatter\"&gt;年龄&lt;/th&gt; &lt;th field=\"headImage\" width=\"30\" formatter=\"headImageFormatter\"&gt;头像&lt;/th&gt; &lt;th field=\"department\" width=\"50\" formatter=\"depFormatter\"&gt;部门&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;!-- 工具栏和搜索表单--&gt; &lt;!-- data-method自定义的属性，建议格式data-名字，通过不同的值动态调用方法 --&gt; &lt;div id=\"tb\"&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" data-method=\"add\" iconCls=\"icon-add\" plain=\"true\"&gt;添加员工&lt;/a&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" data-method=\"edit\" iconCls=\"icon-edit\" plain=\"true\" &gt;编辑员工&lt;/a&gt; &lt;a href=\"javascript:void(0)\" class=\"easyui-linkbutton\" data-method=\"del\" iconCls=\"icon-remove\" plain=\"true\"&gt;删除&lt;/a&gt; &lt;form id=\"searchForm\" action=\"\" method=\"post\"&gt; 用户名: &lt;input name=\"username\" class=\"easyui-textbox\" style=\"width:120px\"&gt; 邮件: &lt;input name=\"email\" class=\"easyui-textbox\" style=\"width:140px\"&gt; 部门:&lt;!-- editable:false不可编辑，只能下拉选中，&lt;options value=\"id\"&gt;name&lt;/option&gt;---valueField相当于下拉列表中的value,textField:相当于name panelHeight:'auto'：高度，表示有几个选项就显示几个选项的高度 --&gt; &lt;input class=\"easyui-combobox\" style=\"width:80px\" name=\"department.id\" data-options=\" url:'depts.json', method:'get', valueField:'id', textField:'name', panelHeight:'auto', editable:false \"&gt; &lt;a href=\"javascript:;\" data-method=\"search\" class=\"easyui-linkbutton\" iconCls=\"icon-search\"&gt;查询&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;div id=\"bs\"&gt; &lt;a class=\"easyui-linkbutton\" data-method=\"save\" iconCls=\"icon-ok\"&gt;保存&lt;/a&gt; &lt;a class=\"easyui-linkbutton\" data-method=\"cancel\" iconCls=\"icon-ok\" id=\"submitBtn\"&gt;取消&lt;/a&gt; &lt;/div&gt; &lt;!-- 添加员工，编辑员工表单 --&gt;&lt;div id=\"employeeDialog\" class=\"easyui-dialog\" style=\"width: 380px; height: 360px; padding: 10px\" data-options=\"title:'用户信息',buttons:'#bs',closed:true\"&gt; &lt;form id=\"ff\" method=\"post\"&gt; &lt;input type=\"hidden\" id=\"empId\" name=\"id\"&gt; &lt;table cellpadding=\"5\"&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;&lt;input class=\"easyui-textbox\" id=\"username\" type=\"text\" name=\"username\" data-options=\"required:true,width:220\"&gt;&lt;/input&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr data-hide=\"true\"&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input class=\"easyui-validatebox\" type=\"password\" id=\"password\" name=\"password\" data-options=\"required:true,width:220,validType:['password']\"&gt;&lt;/input&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr data-hide=\"true\"&gt; &lt;td&gt;确认密码:&lt;/td&gt;&lt;!-- validType都是验证框架里的 --&gt; &lt;td&gt;&lt;input class=\"easyui-validatebox\" type=\"password\" validType=\"equals['#password','jquery']\" name=\"password\" data-options=\"required:true,width:220\"&gt;&lt;/input&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱:&lt;/td&gt; &lt;td&gt;&lt;input class=\"easyui-textbox\" type=\"text\" name=\"email\" data-options=\"required:true,width:220,validType:'email'\"&gt;&lt;/input&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄:&lt;/td&gt; &lt;td&gt;&lt;input class=\"easyui-textbox\" validType=\"integerRange[18,65]\" type=\"text\" name=\"age\" data-options=\"required:true,width:220\"&gt;&lt;/input&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;头像:&lt;/td&gt; &lt;td&gt;&lt;input class=\"easyui-filebox\" type=\"text\" name=\"headImage\" data-options=\"required:true,width:220,buttonText:'选择头像'\"&gt;&lt;/input&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;部门:&lt;/td&gt; &lt;td&gt; &lt;input class=\"easyui-combobox\" style=\"width:140px\" name=\"department.id\" data-options=\" url:'depts.json', method:'get', valueField:'id', textField:'name', panelHeight:'auto', required:true, editable:false \"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; //请求数据 $(\"#tt\").datagrid('load','employee.json'); //给按钮添加事件 //data-method是自定义的属性，格式data-名字 $(\"a[data-method]\").on(\"click\",function()&#123; //下面代码等于$(this).attr(\"method\"); var methodName = $(this).data(\"method\"); methodObj[methodName]();//动态调用对应的方法 &#125;); &#125;) function ageFormatter(value) &#123; /* 年龄大于25的标红 */ if (value != \"\" &amp;&amp; value != null &amp;&amp; value&gt;25) &#123; return \"&lt;font style='color:red'&gt;\"+value+\"&lt;/font&gt;\"; &#125; else &#123; //没有大于25返回原来的值 return value; &#125; &#125; function headImageFormatter(value) &#123; if (value != \"\" &amp;&amp; value != null) &#123; /* 图片显示 */ return \"&lt;img src='\"+value+\"' alt='无图片' width='30px' height='30px'/&gt;\"; &#125; &#125; function depFormatter(obj) &#123; if (obj) &#123; return obj.name;/* 返回部门的名称 */ &#125; else &#123; return \"无部门\"; &#125; &#125; var methodObj = &#123; add:function() &#123; //alert(\"保存\") //打开前要清空表单数据 $(\"#ff\").form('clear'); //隐藏密码框 $(\"tr[data-hide]\").show(); //启用验证 $(\"tr[data-hide] input\").validatebox(\"enableValidation\"); //打开保存面板 $(\"#employeeDialog\").dialog('open'); &#125;, save:function() &#123; /* 获取隐藏与的id */ var id = $(\"#empId\").val(); var url = \"/save\"; if (id) &#123; url = \"/edit\" &#125; $('#ff').form('submit', &#123; //url: 'success.json', url: url, onSubmit: function()&#123; var isValid = $(this).form('validate'); if (!isValid)&#123; $.messager.alert(\"提示\",\"请正确填写表单！\", 'warning'); // 如果表单是无效的则隐藏进度条 &#125; return isValid; // 返回false终止表单提交 &#125;, success: function(data)&#123; //将json字符串转为json对象 var result = JSON.parse(data); if (result.success) &#123; $(\"#employeeDialog\").dialog('close'); $.messager.alert(\"提示\", \"保存成功\", 'info'); //调用重新加载数据的方法 $(\"#employeeDialog\").datagrid(\"reload\"); &#125; else &#123; $.messager.alert(\"保存失败\", result.msg, 'error'); &#125; &#125; &#125;); &#125;, edit:function() &#123; //获取选中的行 var row = $(\"#tt\").datagrid(\"getSelected\"); if (row) &#123; //隐藏密码框 $(\"tr[data-hide]\").hide(); //取消验证功能 $(\"tr[data-hide] input\").validatebox(\"disableValidation\"); //部门回显 if (row.department) &#123; row[\"department.id\"] = row.department.id; &#125; //加载数据到表单 $(\"#ff\").form(\"load\",row); //弹出表单 $(\"#employeeDialog\").dialog('open'); &#125; else &#123; $.messager.alert('温馨提示','亲，请选中一行在修改!','warning'); &#125; &#125;, del:function() &#123; //获得被选中的行 var row = $(\"#tt\").datagrid(\"getSelected\"); //console.log(row); if (row) &#123; //如果有选中的 var id = row.id; $.messager.confirm('确认对话框', '确定要删除这条数据吗？', function(r)&#123; if (r)&#123; // 退出操作; $.ajax(&#123; type:'get', url:'scuuess.json', data:&#123;\"id\":id&#125;, success:function(data) &#123; var result = JSON.parse(data); if (result.succcess) &#123; $.messager.alert(\"提示\", \"删除成功!\", 'info'); &#125; else &#123; $.messager.alert(\"删除失败\", result.msg, 'error'); &#125; &#125; &#125;); &#125; &#125;); &#125; else &#123; $.messager.alert(\"提示\", \"请选择一行数据!\", 'error'); &#125; &#125;, cancel:function() &#123; $(\"#employeeDialog\").dialog('close'); &#125;, search:function() &#123; //获取查询表单参数 //要引入js文件jquery.jdirk.js var params = $(\"#searchForm\").serializeObject(); console.log(params); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/tags/前端/"}]},{"title":"Easyui学习笔记(一)","slug":"Easyui学习笔记-一","date":"2019-02-27T13:09:55.000Z","updated":"2019-02-27T13:42:46.295Z","comments":true,"path":"2019/02/27/Easyui学习笔记-一/","link":"","permalink":"https://conjurermaple.github.io/2019/02/27/Easyui学习笔记-一/","excerpt":"","text":"EasyUI认识(1) 是一组基于jQuery的UI插件集合;(2) 而jQuery EasyUI的目标就是帮助web开发者更轻松的打造出功能丰富并且美观的UI界面。(3) 学习的时候，成本不大，知识点JS+HTML+CSS+jquery(4) 开发者不需要编写复杂的JavaScript，也不需要对css样式有深入的了解，开发者只有需要了解一些简单的html标签。(5) 学习方法 copy EasyUI学习方式查API复制拷贝+修改 EasyUI 目录结构demo :web案例 demo-mobile:移动端案例 locale:本地化（汉化包） plugins:easyui所有插件 src:插件的源码，如果买了商业授权就有全部源码 themes：主题（皮肤），存放css,img changlog.txt:升级日志 easyloader.js:内部实现了一个js加载器，根据应用的需求加载js文件，而不是一次性加载所有文件； jquery.easyui.min.js:所有插件集的压缩文件 jquery.min.js : easyui当前版本兼容的jquery库 EasyUI简单使用引入easyui需要的js和css；可参考jQuery EasyUI 1.5 版 API 中文版.exe/文档说明。12345678910&lt;!-- easyui的样式主题文件 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/easyui/themes/default/easyui.css\"&gt;&lt;!-- easyui的系统图标--&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/easyui/themes/icon.css\"&gt;&lt;!-- easyui依赖的jquery库--&gt; &lt;script type=\"text/javascript\" src=\"/easyui/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- easyui的插件库--&gt; &lt;script type=\"text/javascript\" src=\"/easyui/jquery.easyui.min.js\"&gt;&lt;/script&gt;&lt;!-- easyui的汉化包 --&gt;&lt;script type=\"text/javascript\" src=\"/easyui/locale/easyui-lang-zh_CN.js\"&gt;&lt;/script&gt; EasyUI创建组件(1)HTML创建组件&lt;标签 class=”easyui-组件名”组件配置title=“xxx”data-options=”title:’xxx’”&gt;&lt;/标签&gt; 还是调用js来完成:$(“#p”).panel({json参数}); 1234567891011&lt;!-- 使用html创建easyui组件(最简单方式) class = \"easyui-panel\" 作用: 告诉easyui需要把div转化为easyui组件. style 作用: 设置组件宽高和其他样式. title,iconCls,collapsible 组件属性: 告诉easyui如何创建这个组件.--&gt;&lt;div id=\"p1\" class=\"easyui-panel\" style=\"width: 400px; height: 400px; padding: 10px; color: red; font-weight: bold; font-size: 18px;\" title=\"我的面板\" iconCls=\"icon-ok\" collapsible=\"true\"&gt; &lt;h1&gt;内容xxxx&lt;/h1&gt;&lt;/div&gt; (2)JS创建组件12345678910111213&lt;script type=\"text/javascript\"&gt; $(function() &#123; //获取p2标签,把他变成easyui面板组件. $(\"#p2\").panel(&#123; //面板属性 title : \"你的面板\", iconCls : \"icon-no\" &#125;); &#125;);&lt;/script&gt;&lt;div id=\"p2\" style=\"width: 400px; height: 400px; padding: 10px; color: red; font-weight: bold; font-size: 18px;\"&gt; &lt;h1&gt;是你面板&lt;/h1&gt;&lt;/div&gt; EasyUI创建组件12$('选择器').名字();//没有传递参数$('选择器').名字(&#123;key1:value,key2:value&#125;);//传递json参数 调用方法1$('选择器').名字('方法名',参数);","categories":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/tags/前端/"}]},{"title":"jquery高级","slug":"jquery高级","date":"2019-02-26T08:34:21.000Z","updated":"2019-02-26T08:47:59.411Z","comments":true,"path":"2019/02/26/jquery高级/","link":"","permalink":"https://conjurermaple.github.io/2019/02/26/jquery高级/","excerpt":"","text":"jquery事件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //jquery注册事件 /*  $(\"#btn\").click(function()//jQuery对象.事件名  $(\"#btn\").bind(‘click’，function() // jQuery对象.bind unbind取消绑定  $(\"#btn\").on(‘click’，function() // jQuery对象.on off取消绑定 */ //事件委托 /* 基本的事件绑定，在功能有一个局限。就是绑定事件的元素， 必须是在绑定的时候已知的、存在的。对于以后出现的元素是不起作用，事件委托就可以处理这种情况。 */ $(function()&#123; $(\"#addFile\").on(\"click\",function()&#123; $(\"#userForm\").append($('&lt;div&gt;附件:&lt;input type=\"file\" name=\"file\" /&gt;&lt;a class=\"delete\" href=\"javascript:;\"&gt;删除&lt;/a&gt;&amp;emsp;&amp;emsp;&amp;emsp;&lt;a class=\"view\" href=\"javascript:;\"&gt;查看&lt;/a&gt;&lt;/div&gt;')); &#125;); //常规的事件绑定方法 发现对于添加的不起作用 //a.delete 找到a标签class为delete的元素 /* $(\"a.delete\").bind(\"click\",function()&#123; alert(\"我被删除了\"); &#125;); */ //使用事件委托 就能解决以上问题 /* $(\"#userForm\").delegate(\"a.delete\",\"click\",function()&#123; alert(\"我被删除了\"); &#125;); */ //delegate方法底层用的是on方法，所以也可以这样写 $(\"#userForm\").on(\"click\",\"a.delete\",function()&#123; alert(\"我被删除了\"); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;button id=\"btn\"&gt;&lt;/button&gt; --&gt; &lt;a id=\"addFile\" href=\"javascript:;\"&gt;添加更多附件&lt;/a&gt; &lt;form id=\"userForm\"&gt; &lt;div&gt; 附件:&lt;input type=\"file\" name=\"file\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt; jquery命名空间123456789101112131415161718192021222324&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //命名空间 语法：事件名称.命名空间 //命名空间可以更加细致的过滤需要增加事件监听的事件源，用来做区分的。简单理解命名空间就是一串字符串。 //例：绑定了2个点击事件 $(function()&#123; $(\"#btn1\").on(\"click.bt1\",function()&#123; alert(\"点击\"); &#125;); $(\"#btn1\").on(\"click.bt2\",function()&#123; alert(\"再次点击\"); &#125;); //取消第二个点击事件 //$(\"#btn1\").off(\"click.bt2\"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"按钮1\" id=\"btn1\"/&gt;&lt;/body&gt; jquery继承（扩展）1234567891011121314151617181920212223242526272829&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; /* 要想给jQuery对象进行功能扩展，就应该在原型prototype上扩展。搜索源码：发现： jQuery源码：就是在扩展原型jQuery.fn = jQuery.prototype=$.fn. 扩展分为单一扩展和连续扩展 */ $(function()&#123; //单一扩展 //扩展getHtml和setHtml方法 $.fn.getHtml = function() &#123; return $(this).html(); &#125;; $.fn.setHtml = function(value) &#123; $(this).html(value); &#125; console.log($(\"div\").getHtml()); $(\"div\").setHtml(\"更改内容\"); console.log($(\"div\").getHtml()); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div内容&lt;/div&gt;&lt;/body&gt; 手写简单jquery插件12345678910111213141516171819202122232425262728293031323334353637383940&lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .divSmallClass &#123; width: 100px; height: 100px; border: #FF0000 4px dotted; margin-top: 10px; &#125; .divBigClass &#123; width: 200px; height: 200px; border: #FF0000 4px dotted; margin-top: 10px; background-color:darkblue &#125; &lt;/style&gt;&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $.fn.plugin=function(className) &#123; $(this).hover( function()&#123; //添加样式 $(this).addClass(className); &#125;, function() &#123; //移除样式 $(this).removeClass(className); &#125; ); &#125;; $(\"#myDiv\").plugin(\"divBigClass\"); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myDiv\" class=\"divSmallClass\"&gt;&lt;/div&gt;&lt;/body&gt; 手写datagrid数据表格插件data.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 [ &#123; \"id\":1, \"username\":\"admin\", \"password\":\"62efb964427b82a243c4fb11c628f986\", \"tel\":\"100001\", \"email\":\"admin1@qq.com\", \"age\":20, \"headImage\":\"/avatars/avatar1.png\" &#125;, &#123; \"id\":2, \"username\":\"admin2\", \"password\":\"e9f128d79283d54b1eb25f23b1c17b5a\", \"tel\":\"100002\", \"email\":\"admin2@qq.com\", \"age\":20, \"headImage\":\"/avatars/avatar2.png\" &#125;, &#123; \"id\":4, \"username\":\"admin4\", \"password\":\"63eac0108bbcfd82f5a8ed69e7299496\", \"tel\":\"100004\", \"email\":\"admin4@qq.com\", \"age\":50, \"headImage\":\"/avatars/avtar3.png\" &#125;, &#123; \"id\":5, \"username\":\"admin5\", \"password\":\"1c7406e47313a524a9efb0cc3c4700ed\", \"tel\":\"100005\", \"email\":\"admin5@qq.com\", \"age\":20, \"headImage\":\"/avtars/avtars5.png\" &#125;, &#123; \"id\":6, \"username\":\"admin6\", \"password\":\"940d91aa62e73615e7e9a30b7c058060\", \"tel\":\"100006\", \"email\":\"admin6@qq.com\", \"age\":20, \"headImage\":\"/avtars/avtars1.png\" &#125;, &#123; \"id\":8, \"username\":\"admin8\", \"password\":\"51016840c4310d71afe84974f567f82e\", \"tel\":\"100008\", \"email\":\"admin7@qq.com\", \"age\":40, \"headImage\":\"/avtars/avtars1.png\" &#125;, &#123; \"id\":9, \"username\":\"admin9\", \"password\":\"2c5178244be630742a35b3f851495f6f\", \"tel\":\"100009\", \"email\":\"admin8@qq.com\", \"age\":20, \"headImage\":\"/avtars/avtars1.png\" &#125;, &#123; \"id\":10, \"username\":\"admin10\", \"password\":\"ed91500191005f7843190aa1a2b814ad\", \"tel\":\"1000010\", \"email\":\"admin10@qq.com\", \"age\":20, \"headImage\":\"/avtars/avtars1.png\" &#125;, &#123; \"id\":11, \"username\":\"admin11\", \"password\":\"8ad812c7e52a6c8811c0da9bd479fd7b\", \"tel\":\"1000011\", \"email\":\"admin11@qq.com\", \"age\":20, \"headImage\":\"/avtars/avtars1.png\" &#125;, &#123; \"id\":12, \"username\":\"admin12\", \"password\":\"8b7c045a3c23077628f271c3cbb1ebd9\", \"tel\":\"1000012\", \"email\":\"admin12@qq.com\", \"age\":30, \"headImage\":\"/avtars/avtars2.png\" &#125;] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $.fn.datagrid=function(json) &#123; //console.log(json.url); var url = json.url; if (url) &#123; //如果url有值 var table = $(this); // 获取所有tr下的th var ths = table.find(\"tr th\"); $.get(url,function(data) &#123; //console.log(data); for (var i = 0; i &lt; data.length; i++) &#123; var tr=\"&lt;tr&gt;\"; for (var j = 0; j &lt; ths.length; j++) &#123; //获取属性field var field = $(ths[j]).attr(\"field\"); var format = $(ths[j]).attr(\"format\"); //console.log(field); //console.log(data[i][field]); if (format) &#123; //动态调用函数 tr += \"&lt;td&gt;\"+window[format](data[i][field])+\"&lt;/td&gt;\"; &#125; else &#123; tr += \"&lt;td&gt;\"+data[i][field]+\"&lt;/td&gt;\"; &#125; &#125; tr += \"&lt;/tr&gt;\"; table.append(tr); &#125; &#125;,\"json\"); &#125; &#125;; $(\"#dg\").datagrid(&#123; url:\"data.json\" &#125;); &#125;); function ageFormat(value) &#123; //年龄大于20显示红色 return value&amp;&amp;value&gt;20?\"&lt;font color='red'&gt;\"+value+\"&lt;/font&gt;\":value; &#125; function headImageFormat(value) &#123; return value?\"&lt;img src='\"+value+\"'/&gt;\":\"\"; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" id=\"dg\"&gt; &lt;tr&gt; &lt;!-- 手动添加属性 --&gt; &lt;th field=\"id\"&gt;id&lt;/th&gt; &lt;th field=\"username\"&gt;username&lt;/th&gt; &lt;th field=\"password\"&gt;password&lt;/th&gt; &lt;th field=\"tel\"&gt;tel&lt;/th&gt; &lt;th field=\"email\"&gt;email&lt;/th&gt; &lt;th field=\"age\" format=\"ageFormat\"&gt;age&lt;/th&gt; &lt;th field=\"headImage\" format=\"headImageFormat\"&gt;headImage&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;`","categories":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/tags/前端/"}]},{"title":"js进阶(高级)","slug":"js进阶-高级","date":"2019-02-26T08:04:58.000Z","updated":"2019-02-26T08:12:28.023Z","comments":true,"path":"2019/02/26/js进阶-高级/","link":"","permalink":"https://conjurermaple.github.io/2019/02/26/js进阶-高级/","excerpt":"","text":"js一切皆对象12345678910//js一切皆对象 var num = 2331.232342; //看似基本数据类型 console.log(num.toFixed(2)); //也能调用方法 /* js中可以将一切类型当成是对象来使用  基本数据类型:number/boolean/string/null(值:null)/undefined(undefined)  引用数据类型:Object/Array/Regexp/Date/Number/Boolean/String... */ console.log(typeof num);//number js中的true和false12345678910111213 /* js true和false js 中所有值的真假性: 0,\"\",undefined,NaN,null,false(基本数据类型的false)为false,其他值都为true.*/var b1 = false; //这是布尔值if (b1) &#123; alert(1); //不会执行&#125;var b2 = new Boolean(true); //这是对象if (b2)&#123; //表示有值就为true alert(2); //会执行&#125; js操作创建对象123456789101112131415161718 //创建对象//方式一：/* var obj = new Object();obj.name=\"张三\";obj.age=19;console.log(obj); *///方式二：/* var obj2 = &#123;\"name\":\"李四\",\"age\":20&#125;;console.log(obj2);//方式三：new一个具体的类型function Person()&#123; //相当于构造方法 &#125;*//* var person = new Person();person.name=\"马子\";person.age=23;console.log(person); */ 添加属性或方法123456789 var obj = new Object();obj.name=\"属性\";obj[\"age\"]=19;//添加方法obj.say=function()&#123; console.log(this.name);&#125;//obj.say(); ####删除属性123 //删除属性/* delete obj.name;console.log(obj.name); */ 遍历对象123456789 //遍历对象for (var p in obj) &#123; console.log(p); if (typeof obj[p] == 'function') &#123; //判断是否是函数 obj[p](); //调用函数 &#125; else &#123; console.log(obj[p]); &#125;&#125; json字符串转json对象1234567891011121314151617//方式一:eval 要加(); key可以是双引号也可以是单引号 //var jsonStr = '&#123;\"name\" : \"王麻子\",\"age\" : 16,\"sex\" : \"男\"&#125;';//json字符串 //json数组字符串 var jsonStr = '[&#123;\"name\" : \"王麻子\",\"age\" : 16,\"sex\" : \"男\"&#125;,&#123;\"name\" : \"张麻子\",\"age\" : 26,\"sex\" : \"女\"&#125;]'; /* var jsonObj = eval(\"(\"+jsonStr+\")\"); console.log(jsonObj); var obj = &#123;&#125;; console.log(obj.toSource()); //自动加了() */ //方式二：window.JSON.parse(jsonStr); 注意：key必须是双引号,可以省略window /* var jsonObj = JSON.parse(jsonStr); console.log(jsonObj); */ //方式三：$.parseJSON(jsonStr) 底层采用的是JSON.parse(jsonStr) 要引入jquery var jsonObj = $.parseJSON(jsonStr); console.log(jsonObj); js属性和方法拷贝12345678910111213141516171819202122232425//使用遍历通过hasOwnProperty方法判断是否已经存在这个属性或者方法 /* 使用场景： 修改一条数据回显时，不用去查询，直接属性拷贝 */ var obj1 = &#123; name:\"test1\", address:\"成都\", age:20, sex:\"男\" &#125;; var obj2 = &#123; name:\"test2\", sex:\"女\" &#125;; //拷贝属性 for (var p in obj1) &#123; //判断obj2是否有这个属性 if (!obj2.hasOwnProperty(p)) &#123; //如果没有 obj2[p]=obj1[p]; &#125; &#125; console.log(obj2); js中的对象12345678910111213141516//函数也是对象 /* var add = new Function(\"a\",\"b\",\"return a+b\"); console.log(add(1,2)); add.age=20; add.name=\"pj\"; //函数的name属性是只读属性，不能修改 console.log(add.age); console.log(add.name);//anonymous var name=\"pj\"; console.log(name);//pj */ //window.name属性 //name未定义，也能打印，是空字符串 console.log(name); name=\"pj\";//给window.name赋值 console.log(name); 修改this指向123456789101112131415161718192021222324252627//this 谁调用就指向谁 /* var obj1 = &#123; name:\"pj\" &#125;; function say() &#123; return this.name; &#125; obj1.say = say; console.log(obj1.say()); //pj console.log(say());//打印的是window.name也就是空字符串 */ //修改this指向 /* call（thisObject,args1,args2...）//第一个参数，是调用对象；第2-n个参数是函数需要的参数，一个个的写 apply（thisObject,[args1,args2]）//第一个参数，是调用对象,第2个参数是函数需要的参数，是一个数组 */ function say() &#123; return this.name; &#125; var obj1 = &#123;name:\"test1\"&#125;; var obj2 = &#123;name:\"test2\"&#125;; console.log(say()); //打印的是window.name的值 //修改this指向 console.log(say.call(obj1));//test1 console.log(say.apply(obj2));//test2 prototype原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;script type=\"text/javascript\"&gt; //prototype-使您有能力向对象添加属性和方法(原类型) /* Javascript中的每一个对象都有一个prototype属性(__proto__)，这个属性是一个引用，这个引用指向对象的原型。对象的实例由两部分组成：  对象的自定义属性部分(就是我们的构造函数中定义的属性)  对象原型部分，原型也是一个对象，指向对象类型的原型。 */ function User(name, age) &#123; this.name=name; this.age=age; &#125; //通过console.dir()来查看对象的目录组成结构。 //这里我用chrome浏览器打开才看见__proto__属性 var zs = new User(\"zs\",18); console.dir(zs); var li = new User(\"li\",20); console.dir(li); //原型共享 //同一个对象的各个实例的原型(__proto__)是相等的 console.log(zs.__proto__==li.__proto__);//true //对象属性访问过程 /* 对象访问属性，先在自定义部分查找，如果没有找到，就会去在原型上面查找 //原型共享 */ User.prototype.eat=function(name)&#123; console.log(name+\"正在吃\"); &#125; //发现在原型上增加了eat方法，所有对象都能使用 zs.eat(zs.name); li.eat(li.name); //对象属性的访问过程 function sayName() &#123; console.log(this.name); &#125; function Person(name, age) &#123; this.name=name; this.age=age; this.sayName=sayName; &#125; var obj1 = new Person(\"obj1\",10); var obj2 = new Person(\"obj2\",20); Person.prototype.sayName=function(name) &#123; console.log(name+\"说\"); &#125; //发现调用的是自身的方法 obj1.sayName(obj1.name); obj2.sayName(obj2.name); //原型使用场景 /* 代码到了一定程序，不建议修改原来的代码功能,使用原型为所有相应对象扩展功能 js的很多原生对象功能不够，可以使用原型进行扩展 */ &lt;/script&gt; 回调函数12345678910&lt;script type=\"text/javascript\"&gt; //如果你把函数的引用（地址）作为参数传递给另一个函数，当这个引用被用来调用其所指向的函数时，我们就说这是回调函数。 //如定时器，ajax的回调函数 //1秒后执行 setTimeout(function()&#123; console.log(1); &#125;,1000); //上面使用的是回调函数也是匿名函数 &lt;/script&gt; 匿名函数12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; var x = 10; var y = 50; var result = x*y; console.debug(result); console.debug(window); //定义一个属性默认是在window上的，所以这里的x,y,result都是在window上，是一个全局变量。当我使用完x,y,result //后，不再使用的时候。这样会造成一个作用域的污染。 //匿名函数顾名思义就是没有名字的函数，只使用一次 //写法有三种 //第一种 (function()&#123;&#125;)//推荐写法 (function()&#123;&#125;)()表示调用 (function(x,y)&#123; console.log(x+y); &#125;)(1,2); //第二种 ~function(x,y)&#123; console.log(x+y); &#125;(1,2); //第三种 +function(x,y)&#123; console.log(x+y); &#125;(1,2);&lt;/script&gt; 闭包(与匿名函数结合使用)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;script type=\"text/javascript\"&gt; //闭包 简单理解就是：函数中可以使用函数之外定义的变量。一种封装特性 //闭包第一种用法:函数中可以使用函数之外定义的变量。 var name = \"zs\"; function eat() &#123; console.log(name); &#125; eat(); //闭包第二种用法:通过闭包实现只读属性 var result = 0; function getResult() &#123; result++; return result; &#125; console.log(getResult()); //1 console.log(getResult()); //2 console.log(getResult()); //3 result = 2; //给result重新赋值 console.log(getResult()); //3 console.log(getResult()); //4 /*此时esult可以被外界修改，我们是想不能修改，只能计数，因为result的范围在window上，是一个全局变量，需要缩小作用域， 我们可以使用匿名函数，而且需要只读，可以使用闭包，闭包+匿名函数就可以实现计数器功能。*/ (function()&#123; var id = 1; window.getId=function() &#123; return id++;//执行一次匿名函数后id返回1后加1 &#125; &#125;)();//这里执行了一次 console.debug(getId());//1 console.debug(getId());//2 console.debug(getId());//3 id=1;//无法修改 console.debug(getId());//4 console.debug(getId());//5 //例题1 /* var name = \"The Window\"; var object = &#123; name : \"My Object\", getNameFunc : function()&#123; alert(\"1:\"+this);//object return function()&#123; alert(\"2:\"+this);//window return this.name; //The Window &#125;; &#125; &#125;; alert(object.getNameFunc()());//多了括号是执行里面的那层函数 */ //例题2 /* var name = \"The Window\"; var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; //object return function()&#123; return that.name; //My Object &#125;; &#125; &#125;; alert(object.getNameFunc()()); *///例题3 function Hello()&#123; alert(\"Hello\"); &#125;; Hello(); //Hello World function Hello() &#123; alert(\"Hello World\"); &#125; Hello(); //Hello World //两个都是Hello World，因为是后面的那个函数编译时会覆盖前面那个&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/tags/前端/"}]},{"title":"深入Spring笔记(一)","slug":"深入Spring-一","date":"2019-02-24T12:15:09.000Z","updated":"2019-02-24T12:22:53.757Z","comments":true,"path":"2019/02/24/深入Spring-一/","link":"","permalink":"https://conjurermaple.github.io/2019/02/24/深入Spring-一/","excerpt":"","text":"Spring特征1、轻量级：可以实现零配置开发、API使用简单 2、面向Bean：只需要编写非常普通的bean、不需要去实现接口或者继承一个类 3、松耦合：充分利用AOP思想，可以先自己开发自己的，后面再进行结合 4、无缝集成其他主流框架，如Mybatis、Hibernate 5、Spring中运用了很多设计模式，将他们运用的淋漓尽致 Spring为什么会存在简化开发是Spring的宗旨 采取了以下策略： 1、基于POJO的轻量级和最小侵入性（代码嵌套引用）编程 2、通过依赖注入和面向接口松耦合 3、基于切面和惯性进行声明式编程 4、通过切面和模板减少样板式代码 Spring核心概念1、控制反转 传统方式是需要手动去new对象，有了spring只需要在类中声明成员变量，实例化交给spring去做 2、IOC容器 用来装bean的，创建bean后，存入IOC容器管理 3、依赖注入 前提：创建bean并且放入IOC容器；即依赖注入依赖于IOC容器 用到对象时，比如调用方法，spring会将创建的bean注入到声明的成员变量 对象与对象之间的依赖关系 注入方式： set注入 自动注入 @Autowired按类型注入 @Autowired按名称注入 构造注入 4、面向切面（AOP） 先把一个模块拆了，分别开发，发布的时候，再组装运行 一个切面就是一个规则 主要就是指定规则（对接的规则）","categories":[{"name":"Spring","slug":"Spring","permalink":"https://conjurermaple.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://conjurermaple.github.io/tags/Spring/"}]},{"title":"Jquery+Ajax+Servlet实现省市二级联动","slug":"Jquery-Ajax-Servlet实现省市二级联动","date":"2019-02-24T10:19:27.000Z","updated":"2019-02-24T12:04:15.236Z","comments":true,"path":"2019/02/24/Jquery-Ajax-Servlet实现省市二级联动/","link":"","permalink":"https://conjurermaple.github.io/2019/02/24/Jquery-Ajax-Servlet实现省市二级联动/","excerpt":"","text":"domain类 1234567891011121314151617181920212223242526272829303132333435 /** * @author maple * * 省份 */public class Province &#123; /**省份编号*/ private Long id; /**省份名称*/ private String name; public Province(Long id, String name) &#123; super(); this.id = id; this.name = name; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; //获取省份---是模拟，就不从数据库里读取了 public static List&lt;Province&gt; getAllProvince() &#123; List&lt;Province&gt; provinceList = Arrays.asList(new Province(1L,\"四川省\"),new Province(2L,\"湖南省\"),new Province(3L,\"湖北省\")); return provinceList; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940 /** * @author maple *城市 */public class City &#123; /**城市编号*/ private Long id; /**城市名称*/ private String name; public City(Long id, String name) &#123; super(); this.id = id; this.name = name; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public static List&lt;City&gt; getCity(Long id) &#123; List&lt;City&gt; cityList = null; if (id==1) &#123; cityList = Arrays.asList(new City(4L, \"成都市\"),new City(5L, \"南充市\"),new City(6L, \"雅安市\"),new City(7L, \"自贡市\")); &#125; else if (id==2) &#123; cityList = Arrays.asList(new City(8L, \"长沙市\"),new City(9L, \"株洲市\"),new City(10L, \"湘潭市\")); &#125; else if (id==3) &#123; cityList = Arrays.asList(new City(11L, \"武汉市\"),new City(12L, \"黄冈市\"),new City(13L, \"襄阳市\")); &#125; return cityList; &#125;&#125; Servlet代码 将list转为json对象时要加包 12345678910111213141516171819202122232425 @WebServlet(\"/query\")public class QueryServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 post请求使用 req.setCharacterEncoding(\"UTF-8\"); //设置响应的内容类型和编码 //resp.setContentType(\"text/html;charset=utf-8\"); //使用以下代码，前台可以不用解析json，直接遍历 resp.setContentType(\"text/json;charset=utf-8\"); //获取参数，传过来的是省份id String id = req.getParameter(\"id\"); if (id != null) &#123; List&lt;City&gt; cityList = City.getCity(Long.parseLong(id)); //将list转成json对象进行输出 JSON cityJson = JSONSerializer.toJSON(cityList); resp.getWriter().print(cityJson); &#125; else &#123; List&lt;Province&gt; provinceList = Province.getAllProvince(); JSON provinceJson = JSONSerializer.toJSON(provinceList); resp.getWriter().print(provinceJson); &#125; &#125;&#125; 前台html12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $.get(\"/query\",function(data)&#123; //将数据转发成json对象 var provinceJson = JSON.parse(data); //each遍历 index:索引 domEle:元素，是dom对象 $(provinceJson).each(function(index, domEle)&#123; //追加选项 $(\"#provinceSelect\").append(\"&lt;option value='\"+provinceJson[index].id+\"'&gt;\"+provinceJson[index].name+\"&lt;/option&gt;\"); &#125;); &#125;); //onchange事件：一旦更改了选项就触发 $(\"#provinceSelect\").on(\"change\",function()&#123; //如果没有这句代码城市选项会进行累加，试着可以去掉这行代码看效果 $(\"#citySelect\").html(\"&lt;option&gt;--请选择--&lt;/option&gt;\"); //$(this).val() 下拉列表选中的value $.get(\"/query\",&#123;\"id\":$(this).val()&#125;,function(data)&#123; var cityJson = JSON.parse(data); $(cityJson).each(function(index, domEle)&#123; $(\"#citySelect\").append(\"&lt;option value='\"+cityJson[index].id+\"'&gt;\"+cityJson[index].name+\"&lt;/option&gt;\"); &#125;); &#125;,\"json\"); //如果在这里添加了\"json\"这个参数，前台不用再去解析了，直接遍历 &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 省份&lt;select id=\"provinceSelect\"&gt; &lt;option&gt;--请选择--&lt;/option&gt; &lt;/select&gt; 城市&lt;select id=\"citySelect\"&gt; &lt;option&gt;--请选择--&lt;/option&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/tags/前端/"}]},{"title":"Jquery核心操作","slug":"Jquery核心操作","date":"2019-02-24T01:52:48.000Z","updated":"2019-02-24T10:18:30.169Z","comments":true,"path":"2019/02/24/Jquery核心操作/","link":"","permalink":"https://conjurermaple.github.io/2019/02/24/Jquery核心操作/","excerpt":"","text":"jquery认识jquery是一个JavaScript的前端框架优势： 1、链式语法和多功能接口 2、高效灵活的css选择器，可扩展 3、插件丰富 4、浏览器兼容性好 使用jquery(jquery加载机制与js的加载机制)引入js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //js获取id为myDiv的元素 var divObj = document.getElementById(\"myDiv\"); //null //jquery获取id为myDiv的元素 $(function()&#123; var jqObj = $(\"#myDiv\"); console.log(jqObj); &#125;); console.log(divObj); /* 第一个打印null，说明没有获取到 这是因为程序是从上到下执行的 解决方案： 将js代码写到body末尾 将js代码写在 window.onload=function()&#123;&#125;;里 jquery代码写在$(function()&#123;&#125;;里 他获取到了是因为jquery是读取完页面元素后才执行，所以能获取到 */ //js获取id为myDiv的元素 window.onload = function() &#123; var divObj = document.getElementById(\"myDiv\"); //null &#125; //jquery获取id为myDiv的元素 $(function()&#123; var jqObj = $(\"#myDiv\"); console.log(jqObj); &#125;); console.log(divObj); /* 发现总是jquery获取到元素 window.onload是整个页面加载完成后才执行 jquery是读取完页面元素后才执行，所以能获取到 */ /* jquery其他写法 */ $(document).ready(function() &#123; &#125;); /* $等同于jQuery 注意:Q是大写 $(\"#myDiv\");等于jQuery(\"#myDiv\"); */&lt;/script&gt;html代码&lt;body&gt; &lt;!--注意：如果存在多个id相同的元素，jquery只获取第一个元素，所以及其建议id保持唯一--&gt; &lt;div id=\"myDiv\"&gt;&lt;/div&gt;&lt;/body&gt; dom对象和jquery对象转换以下代码使用浏览器f12查看效果 123456789101112131415161718192021 &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function() &#123; var jqueryObj = $(\"#myDiv\"); var divObj = document.getElementById(\"myDiv\"); console.log(divObj); console.log(jqueryObj); console.log(\"============================\"); //将dom对象转换为jquery对象 var jqueryObj2 = $(divObj); console.log(jqueryObj2); //将jquery对象转换为dom对象 var divObj2 = jqueryObj[0]; console.log(divObj2); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myDiv\"&gt;&lt;/div&gt;&lt;/body&gt; jquery选择器选择器是为了定位元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function() &#123; //id选择器 var idObj = $(\"#myDiv\"); console.log(idObj); //class选择器 var classObj = $(\".myDiv\"); console.log(classObj); //元素选择器 选择一个元素 var eleObj = $(\"a\"); console.log(eleObj); //选择所有元素----通配符 var allObj = $(\"*\"); console.log(allObj); //选择多个元素 var manyObj = $(\"div,a\"); console.log(manyObj); //祖先 后代 包括孙子 //$(\"ul li\").css('color','red'); //父亲 儿子 //$(\"form&gt;input\").val(\"test\"); //元素 紧接下一个元素 即同级的第一个元素 //$(\"form+input\").val(\"xxx\"); //元素 同级的所有元素 val(\"xxx\")等于value=\"xxx\" $(\"form~input\").val(\"xxx\"); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myDiv\"&gt;&lt;/div&gt; &lt;div class=\"myDiv\"&gt;&lt;/div&gt; &lt;a&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;&lt;a&gt;a1&lt;/a&gt;&lt;/li&gt; &lt;a&gt;a2&lt;/a&gt; &lt;/ul&gt; &lt;form&gt; &lt;label&gt;Name:&lt;/label&gt; &lt;input name=\"name\" /&gt; &lt;fieldset&gt; &lt;label&gt;Newsletter:&lt;/label&gt; &lt;input name=\"newsletter\" /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;input name=\"none\" /&gt;&lt;/body&gt; jquery注册事件123456789101112131415161718192021222324252627282930 &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; //方式一：低版本才能用，我用的是版本2，不能用 //缺点：不能取消事件 /* $(\"#btn\").onclick(function()&#123; alert(1); &#125;); */ //方式二： /* $(\"#btn\").on(\"click\",function()&#123; alert(2); &#125;); */ //取消点击事件 //$(\"#btn\").off(\"click\"); //方式三： $(\"#btn\").bind(\"click\",function()&#123; alert(3); &#125;); //取消事件 $(\"#btn\").unbind(\"click\"); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;点击&lt;/button&gt;&lt;/body&gt; jquery方法（结合示例）示例1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#btn\").on(\"click\",function() &#123; //input[name=hobbies]:checked 表示input类型name=hobbies并且被选中的元素 alert($(\"input[name=hobbies]:checked\").length); &#125;); $(\"p\").on(\"click\",function() &#123; //隐藏当前元素 $(this).hide(); &#125;); /* :odd 匹配所有索引值为奇数的元素，从 0 开始计数,对应表格的就是偶数行 :even 匹配所有索引值为偶数的元素，从 0 开始计数,对应表格的就是奇数行 */ $(\"table tr:odd\").css('background-color','red'); $(\"table tr:even\").css('background-color','yellow'); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 篮球 &lt;input type=\"checkbox\" name=\"hobbies\" /&gt; 足球 &lt;input type=\"checkbox\" name=\"hobbies\" /&gt; 羽毛球 &lt;input type=\"checkbox\" name=\"hobbies\" /&gt; &lt;input value=\"点击获取选中个数\" type=\"button\" id=\"btn\" /&gt; &lt;br /&gt;点击p标签隐藏 &lt;br /&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;br /&gt;给不同的行添加颜色&lt;br/&gt; &lt;table border=\"1\" width=\"200px\"&gt; &lt;tr&gt; &lt;td&gt;item1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;item2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;item3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;item4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;item5&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 示例2：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; //一行代码 $(\"#btn1\").on('click',function()&#123; //#select1 option:selected 找到id为select1 下面的选中的option 然后将其添加到id为select2里 $(\"#select1 option:selected\").appendTo(\"#select2\"); &#125;); $(\"#btn2\").on('click',function()&#123; //将id为select1下的所有option添加到id为select2里 $(\"#select1 option\").appendTo(\"#select2\"); &#125;); $(\"#btn3\").on('click',function()&#123; //#select1 option:selected 找到id为select2 下面的选中的option 然后将其添加到id为select1里 $(\"#select2 option:selected\").appendTo(\"#select1\"); &#125;); $(\"#btn4\").on('click',function()&#123; //$(\"#select2 option\").appendTo(\"#select1\"); //使用append方法 添加 $(\"#select1\").append(\"#select2 option\"); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt; &lt;select id=\"select1\" style=\"width:100px\" size=\"10\" multiple=\"multiple\"&gt; &lt;option value=\"选项1\"&gt;选项1&lt;/option&gt; &lt;option value=\"选项2\"&gt;选项2&lt;/option&gt; &lt;option value=\"选项3\"&gt;选项3&lt;/option&gt; &lt;option value=\"选项4\"&gt;选项4&lt;/option&gt; &lt;option value=\"选项5\"&gt;选项5&lt;/option&gt; &lt;option value=\"选项6\"&gt;选项6&lt;/option&gt; &lt;option value=\"选项7\"&gt;选项7&lt;/option&gt; &lt;option value=\"选项8\"&gt;选项8&lt;/option&gt; &lt;option value=\"选项9\"&gt;选项9&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td align=\"center\"&gt; &lt;input type=\"button\" id=\"btn1\" value=\"--&gt;\"/&gt;&lt;br/&gt; &lt;input type=\"button\" id=\"btn2\" value=\"==&gt;\"/&gt;&lt;br/&gt; &lt;input type=\"button\" id=\"btn3\" value=\"&lt;--\"/&gt;&lt;br/&gt; &lt;input type=\"button\" id=\"btn4\" value=\"&lt;==\"/&gt; &lt;/td&gt; &lt;td&gt; &lt;select id=\"select2\" style=\"width:100px\" size=\"10\" multiple=\"multiple\"&gt;&lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 示例3：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#checkAll\").on('click',function()&#123; /* input[name=hobbies]：input类型name=hobbies的元素 prop:改变属性的方法，attr方法也可以 prop(\"checked\",true); 选中 */ //$(\"input[name=hobbies]\").attr(\"checked\",true); $(\"input[name=hobbies]\").prop(\"checked\",true); &#125;); $(\"#checkNotAll\").on(\"click\",function()&#123; $(\"input[name=hobbies]\").prop(\"checked\",false); &#125;); $(\"#checkUnAll\").on(\"click\",function()&#123; var hobbies = $(\"input[name=hobbies]\"); //获取所有的复选框 hobbies.each(function (index, domEle) &#123; //遍历 /* domEle:是dom对象 !domEle.checked:对他原来的属性进行取反 */ $(domEle).prop('checked',!domEle.checked); &#125;); &#125;); &#125;); function checkChange(src)&#123; $(\"input[name=hobbies]\").prop(\"checked\",src.checked); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 请选择你的爱好:&lt;br/&gt; &lt;div&gt; &lt;input type=\"checkbox\" name=\"hobbies\"/&gt;打篮球&amp;nbsp; &lt;input type=\"checkbox\" name=\"hobbies\"/&gt;踢足球&amp;nbsp; &lt;input type=\"checkbox\" name=\"hobbies\"/&gt;上网&amp;nbsp; &lt;/div&gt; &lt;div&gt; &lt;input type=\"checkbox\" onchange=\"checkChange(this)\"/&gt;全选/全不选&lt;br/&gt; &lt;input type=\"button\" id=\"checkAll\" value=\"全选\"/&gt; &lt;input type=\"button\" id=\"checkNotAll\" value=\"全不选\"/&gt; &lt;input type=\"button\" id=\"checkUnAll\" value=\"反选\"/&gt; &lt;/div&gt;&lt;/body&gt; 示例4：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function() &#123; $(\"#btn1\").on(\"click\",function()&#123; $(\"#select\").val(\"2号\"); &#125;); $(\"#btn2\").on(\"click\",function()&#123; $(\"#selectMultiple\").val(['2号','5号']); &#125;); $(\"#btn3\").on(\"click\",function()&#123; $(\"input[type=checkbox]\").val(['复选2','复选4']); &#125;); $(\"#btn4\").on(\"click\",function()&#123; //input[type=radio]:eq(1)表示input类型type=radio的第二个元素 eq从0开始 $(\"input[type=radio]:eq(1)\").prop('checked',true); &#125;); &#125;);&lt;/script&gt;&lt;title&gt;练习5&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=\"btn1\" type=\"button\" value=\"使单选下拉框‘2号’选中\"/&gt;&lt;br/&gt; &lt;input id=\"btn2\" type=\"button\" value=\"使多选下拉框‘2号’和‘5号’选中\"/&gt;&lt;br/&gt; &lt;input id=\"btn3\" type=\"button\" value=\"使复选框‘2号’和‘4号’选中\"/&gt;&lt;br/&gt; &lt;input id=\"btn4\" type=\"button\" value=\"使单选框‘单选2’选中\"/&gt;&lt;br/&gt; &lt;input id=\"btn5\" type=\"button\" value=\"打印已被选中的值\"/&gt;&lt;br/&gt; &lt;form name=\"userForm\"&gt; 单选下拉框&lt;select id=\"select\" name=\"select\"&gt; &lt;option value=\"1号\"&gt;1号&lt;/option&gt; &lt;option value=\"2号\"&gt;2号&lt;/option&gt; &lt;option value=\"3号\"&gt;3号&lt;/option&gt; &lt;option value=\"4号\"&gt;4号&lt;/option&gt; &lt;option value=\"5号\"&gt;5号&lt;/option&gt; &lt;option value=\"6号\"&gt;6号&lt;/option&gt; &lt;/select&gt; 多选下拉框&lt;select id=\"selectMultiple\" multiple=\"multiple\" size=\"6\" name=\"selectMultiple\"&gt; &lt;option value=\"1号\"&gt;01号&lt;/option&gt; &lt;option value=\"2号\"&gt;02号&lt;/option&gt; &lt;option value=\"3号\"&gt;03号&lt;/option&gt; &lt;option value=\"4号\"&gt;04号&lt;/option&gt; &lt;option value=\"5号\"&gt;05号&lt;/option&gt; &lt;option value=\"6号\"&gt;06号&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; 复选框&lt;input value=\"复选1\" type=\"checkbox\" name=\"checkbox\"/&gt;复选1 &lt;input value=\"复选2\" type=\"checkbox\" name=\"checkbox\"/&gt;复选2 &lt;input value=\"复选3\" type=\"checkbox\" name=\"checkbox\"/&gt;复选3 &lt;input value=\"复选4\" type=\"checkbox\" name=\"checkbox\"/&gt;复选4 &lt;input value=\"复选5\" type=\"checkbox\" name=\"checkbox\"/&gt;复选5 &lt;br/&gt; 单选框&lt;input value=\"单选1\" type=\"radio\" name=\"radio\"/&gt;单选1 &lt;input value=\"单选2\" type=\"radio\" name=\"radio\"/&gt;单选2 &lt;input value=\"单选3\" type=\"radio\" name=\"radio\"/&gt;单选3 &lt;input value=\"单选4\" type=\"radio\" name=\"radio\"/&gt;单选4 &lt;/form&gt;&lt;/body&gt; 示例5：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script language=\"javascript\"&gt; $(function()&#123; $(\"#btn_submit\").on('click',function()&#123; //获取文本框的值 var username = $(\"#username\").val(); var email = $(\"#email\").val(); var tel = $(\"#tel\").val(); //追加元素 $(\"#userTbody\").append(\"&lt;tr&gt;&lt;td&gt;\"+username+\"&lt;/td&gt;&lt;td&gt;\"+email+\"&lt;/td&gt;&lt;td&gt;\"+tel+\"&lt;/td&gt;&lt;td&gt;&lt;button onclick='remove(this)'&gt;删除&lt;/button&lt;/td&gt;&lt;/tr&gt;\"); &#125;); $(\"#btn_removeAll\").on(\"click\",function()&#123; //将表格清空 $(\"#userTbody\").empty(); &#125;); &#125;); function remove(src) &#123; //找到tr，删除 //$(src).parent().parent().remove(); //closest(\"tr\") 搜索最近的tr $(src).closest(\"tr\").remove(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form name=\"userForm\"&gt; &lt;center&gt; 用户录入&lt;br/&gt; 用户名:&lt;input id=\"username\" name=\"username\" type=\"text\"/&gt; E-mail:&lt;input id=\"email\" name=\"email\" type=\"text\"/&gt; 电话:&lt;input id=\"tel\" name=\"tel\" type=\"text\"/&gt; &lt;input type=\"button\" value=\"提交\" id=\"btn_submit\"/&gt; &lt;input type=\"button\" value=\"删除所有\" id=\"btn_removeAll\"/&gt; &lt;/center&gt; &lt;/form&gt; &lt;hr/&gt; &lt;table border=\"1\" align=\"center\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;E-mail&lt;/th&gt; &lt;th&gt;电话&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"userTbody\"&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt; 其他方法123456789101112131415161718&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.3.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(function()&#123;//创建元素b ，是dom对象 var b = document.createElement(\"b\"); b.innerHTML = \"创建元素\"; $(\"#myDiv\").append(b); //追加span元素，发现原来的不在，如果想要原来的，这时我们就可以使用追加克隆 //$(\"#myDiv\").append($(\"span\")); //clone()不会克隆其事件，如果事件也想克隆就用clone(true) $(\"#myDiv\").append($(\"span\").clone());&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myDiv\"&gt;&lt;/div&gt; &lt;span&gt;克隆&lt;/span&gt;&lt;/body&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/tags/前端/"}]},{"title":"Ajax结合json案例学习","slug":"Ajax结合json案例学习","date":"2019-02-23T12:07:14.000Z","updated":"2019-02-23T12:38:22.656Z","comments":true,"path":"2019/02/23/Ajax结合json案例学习/","link":"","permalink":"https://conjurermaple.github.io/2019/02/23/Ajax结合json案例学习/","excerpt":"","text":"Ajax介绍百度百科已经很详细的解释了该技术Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 为什么需要Ajax传统的交互方式：是发送请求到后端处理后，再刷新整个页面缺点：如果数据量大，加载会很慢，用户体验性不好 Ajax交互：只会刷新当前页面，也就是局部刷新 Ajax应用场景Ajax的应用场景很多，现在几乎每个web应用都使用了Ajax比如： 1、百度搜索的自动提示 2、无刷新分页 3、用户名的重复检查 4、购物车 5、用户登录（通过Ajax提交请求） 。。。。。。。 同步和异步概念解释同步：一个操作必须等到其他操作执行完后才能执行 例子： 你去上厕所，但只有一个坑，而且还有人，这时你只能等他上完出来，你才能进去上厕所 异步：一个操作不必等到其他操作执行完后才执行，可以一起执行 例子： 你去上厕所，我不需要等他出来，我换一个坑上 Ajax核心对象XMLHttpRequest1、创建XMLHttpRequest对象 //这是IE7+、Firefox、Chrome、Safari 以及 Opera的创建方式 var ajaxObj = new XMLHttpRequest(); //老版本的 Internet Explorer （IE5、IE6） var ajaxObj = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 2、将创建XMLHttpRequest对象封装成一个方法 方式一： 12345678910function createAjax() &#123; var ajaxObj; if (window.XMLHttpRequest) &#123; ajaxObj = new XMLHttpRequest(); &#125; else &#123; ajaxObj = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; return ajaxObj;&#125; 方式二： 123456789function createAjax() &#123; var ajaxObj; try&#123; ajaxObj = new XMLHttpRequest(); &#125;catch(e) &#123; ajaxObj = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; return ajaxObj;&#125; 使用Ajax检查用户名html里代码1234 &lt;!-- 这次不使用form表单提交,使用Ajax --&gt;用户名：&lt;input type=\"text\" id=\"username\" name=\"username\"&gt;密码：&lt;input type=\"password\" id=\"password\" name=\"password\"&gt;&lt;input type=\"button\" onclick=\"checkUsername()\" value=\"提交\"&gt; js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 function checkUsername() &#123; //获取username的值 var username = document.getElementById(\"username\").value; var ajaxObj = createAjax(); //创建对象 //第一个参数是请求方式，第二个参数是请求的路径，也就是提交到哪个路径 /* open(method,url,async) method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步），一定要选择true或 false（同步） */ ajaxObj.open(\"get\",\"/check?username=\"+username,true); //打开连接 ,使用get方式，记住这里暂时不使用post，后面讲，传参与get方式有区别 //监听状态 /* 监听代码为什么要写在send前面？ 代码从上往下执行，有可能已经请求成功了，但是还没有执行监听的代码，从而监听不到 比如： ajaxObj.send(); alert(1)； 执行监听代码 */ //onreadystatechange:每当 readyState 属性改变时，就会调用该函数。 /* readyState:请求状态 0: 请求未初始化 未创建 1: 服务器连接已建立 open()方法 2: 请求已接收 send()方法 3: 请求处理中 服务器处理中 4: 请求已完成，且响应已就绪 响应完毕 status:Http响应状态 200: \"OK\" 请求成功 404: \"NOT FOUND\" 没有找到对应资源 500:\"Server Error\" 服务器端错误 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据 */ ajaxObj.onreadystatechange=function() &#123; if (ajaxObj.readyState==4 &amp;&amp; ajaxObj.status==200) &#123; //说明请求成功并且响应成功 console.log(ajaxObj.responseText);//打印返回的文本内容 &#125; &#125; //发送 ajaxObj.send();&#125; Ajax+json模拟登录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 &lt;script type=\"text/javascript\"&gt; /* json是一种数据交换的格式 由于XML太复杂，抒写严格 比如一个Student对象 XML表示： &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/student&gt; json表示： &#123;\"name\":\"张三\",\"age\":18&#125; */ /* json语法： &#123;key:value,key:value,key:value.....&#125; key可以使用单引号，也可以使用双引号，但建议使用双引号 后面讲json字符串转为json对象的时候讲 有多个？ //这里只列了2个，有多个直接在后面加 [&#123;key:value,key:value,key:value....&#125;,&#123;key:value,key:value,key:value...&#125;] 注意：如果value是字符串，一定要加引号 */ /* 将json格式字符串转为json对象 方式一：eval var jsonStr = '&#123;\"name\":\"张三\",\"age\":18&#125;'; var jsonObj = eval(\"(\"+jsonStr+\")\"); console.log(jsonObj); 我们再看看key使用单引号 发现也可以 var jsonStr = \"&#123;'name':'张三','age':18&#125;\"; var jsonObj = eval(\"(\"+jsonStr+\")\"); console.log(jsonObj); 方式二：JSON.parse(jsonStr); var jsonStr = '&#123;\"name\":\"张三\",\"age\":18&#125;'; var jsonObj = JSON.parse(jsonStr); console.log(jsonObj); 这种方式我们再看看key使用单引号 发现报错 这就是建议全部使用双引号的原因 var jsonStr = \"&#123;'name':'张三','age':18&#125;\"; var jsonObj = JSON.parse(jsonStr); console.log(jsonObj); */ //使用Ajax 的post方式请求以json格式返回---模拟登录function createAjax() &#123; var ajaxObj; if (window.XMLHttpRequest) &#123; //如果有这个对象 ajaxObj = new XMLHttpRequest(); &#125; else &#123; ajaxObj = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; return ajaxObj;&#125; function login() &#123; //获取用户名以及密码 var username = document.getElementById(\"username\").value; var password = document.getElementById(\"password\").value; var ajaxObj = createAjax(); //post方式注意不是在这里传参了 ajaxObj.open(\"post\",\"/login\",true); ajaxObj.onreadystatechange=function() &#123; if (ajaxObj.readyState==4 &amp;&amp; ajaxObj.status==200) &#123; //说明请求成功并且响应成功 var jsonStr = ajaxObj.responseText;//返回的json格式字符串 //将字符串转为对象 var jsonObj = eval(\"(\"+jsonStr+\")\"); //取内容 console.log(jsonObj.success); &#125; &#125; //注意：post方式要加一句代码，使用form表单提交时，浏览器默认会加 ajaxObj.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); //发送 传参 var params = \"username=\"+username+\"&amp;password=\"+password; ajaxObj.send(params);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=\"text\" id=\"username\" name=\"username\"&gt; 密码：&lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;input type=\"button\" onclick=\"login()\" value=\"登录\"&gt;&lt;/body&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://conjurermaple.github.io/tags/前端/"}]},{"title":"JDK原生API解析XML","slug":"JDK原生API解析XML","date":"2019-02-22T05:50:31.000Z","updated":"2019-02-22T05:53:54.248Z","comments":true,"path":"2019/02/22/JDK原生API解析XML/","link":"","permalink":"https://conjurermaple.github.io/2019/02/22/JDK原生API解析XML/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132/** * @throws Exception * 修改某个节点的元素内容 * 将第一个联系人的address的值改为重庆 */ @Test public void test2() throws Exception &#123; //获取DocumentBuilderFactory DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); //获取解析器 DocumentBuilder builder = builderFactory.newDocumentBuilder(); //将内存中的XML解析为Document对象 Document dom = builder.parse(file); //拿到根节点 Element root = dom.getDocumentElement(); //拿到第一个联系人 Element linkman = (Element) root.getElementsByTagName(\"linkman\").item(0); //拿到第一个address Node address = linkman.getElementsByTagName(\"address\").item(0); //此时只是将内存中的数据更改了，没有做同步 address.setTextContent(\"重庆\"); //同步 TransformerFactory transformerFactory = TransformerFactory.newInstance(); //拿到转换器 Transformer transformer = transformerFactory.newTransformer(); //拿到内存里面的数据 Source domSource = new DOMSource(dom); //拿到磁盘上的文件 Result result = new StreamResult(file); transformer.transform(domSource, result); &#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * @throws Exception * 增加一个联系人 */ @Test public void test3() throws Exception &#123; Document dom = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file); //获取根节点 Element root = dom.getDocumentElement(); //创建linkman节点 Element linkman = dom.createElement(\"linkman\"); linkman.setAttribute(\"id\", \"3\"); root.appendChild(linkman); //创建name Element name = dom.createElement(\"name\"); name.setTextContent(\"小米\"); linkman.appendChild(name); //创建email Element email = dom.createElement(\"email\"); email.setTextContent(\"192033344@qq.com\"); linkman.appendChild(email); //创建address Element address = dom.createElement(\"address\"); address.setTextContent(\"成都高新区\"); linkman.appendChild(address); //创建group Element group = dom.createElement(\"group\"); group.setTextContent(\"小米科技有限公司\"); linkman.appendChild(group); //同步 TransformerFactory transformerFactory = TransformerFactory.newInstance(); Transformer transformer = transformerFactory.newTransformer(); Source source = new DOMSource(dom); Result result = new StreamResult(file); transformer.transform(source, result); &#125; 12345678910111213//删除第三个联系人 @Test public void test4() throws Exception &#123; Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file); Element root = document.getDocumentElement(); Node linkman = root.getElementsByTagName(\"linkman\").item(2); linkman.getParentNode().removeChild(linkman); Transformer transformer = TransformerFactory.newInstance().newTransformer(); Source source = new DOMSource(document); Result result = new StreamResult(file); transformer.transform(source, result); &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://conjurermaple.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://conjurermaple.github.io/tags/JAVA/"}]},{"title":"Dom4j解析XML","slug":"Dom4j解析XML","date":"2019-02-22T05:14:50.000Z","updated":"2019-02-22T05:55:59.528Z","comments":true,"path":"2019/02/22/Dom4j解析XML/","link":"","permalink":"https://conjurermaple.github.io/2019/02/22/Dom4j解析XML/","excerpt":"","text":"加入dom4j包 12345678910/** * @throws Exception * 获取Document */ @Test public void test1() throws Exception &#123; SAXReader reader = new SAXReader(); Document document = reader.read(file); System.out.println(document); &#125; 123456789101112131415161718192021/** * @throws Exception * 取出第二个联系人的名字 */ @Test public void test2() throws Exception &#123; SAXReader reader = new SAXReader(); Document document = reader.read(file); //获取根节点 Element rootElement = document.getRootElement(); //拿到所有的linkman List&lt;Element&gt; linkmanList = rootElement.elements(\"linkman\"); //拿到第二个联系人 Element linkman = linkmanList.get(1); /* Element name = linkman.element(\"name\"); String text = name.getText();*/ //拿到name的值 System.out.println(linkman.elementText(\"name\")); &#125; 1234567891011121314151617181920212223242526272829/** * @throws Exception * 修改第一个联系人的地址 */ @Test public void test3() throws Exception &#123; SAXReader reader = new SAXReader(); Document document = reader.read(file); Element rootElement = document.getRootElement(); List&lt;Element&gt; linkmanList = rootElement.elements(\"linkman\"); Element linkman = linkmanList.get(0); Element address = linkman.element(\"address\"); address.setText(\"南充\"); /** * // lets write to a file XMLWriter writer = new XMLWriter( new FileWriter( \"output.xml\" ) ); writer.write( document ); writer.close(); * */ //同步 FileWriter fileWriter = new FileWriter(file); XMLWriter writer = new XMLWriter(fileWriter); writer.write(document); writer.close(); &#125; 123456789101112131415161718192021222324252627/** * @throws Exception * 增加一个联系人 */ @Test public void test4() throws Exception &#123; SAXReader saxReader = new SAXReader(); Document document = saxReader.read(file); Element rootElement = document.getRootElement(); Element linkman = rootElement.addElement(\"linkman\"); Element name = linkman.addElement(\"name\"); name.setText(\"小米\"); Element email = linkman.addElement(\"email\"); email.setText(\"1920347@qq.com\"); Element address = linkman.addElement(\"address\"); address.setText(\"高新区\"); Element group = linkman.addElement(\"group\"); group.setText(\"小米科技有限公司\"); new OutputFormat(); //同步 OutputFormat format = OutputFormat.createPrettyPrint(); FileWriter fileWriter = new FileWriter(file); XMLWriter xmlWriter = new XMLWriter(fileWriter,format); xmlWriter.write(document); xmlWriter.close(); &#125; 12345678910111213141516171819/** * @throws Exception * 删除第三个联系人 */ @Test public void test5() throws Exception &#123; SAXReader saxReader = new SAXReader(); Document document = saxReader.read(file); Element rootElement = document.getRootElement(); List&lt;Element&gt; linkmanList = rootElement.elements(\"linkman\"); Element linkman = linkmanList.get(2); linkman.getParent().remove(linkman); //同步 FileWriter fileWriter = new FileWriter(file); XMLWriter xmlWriter = new XMLWriter(fileWriter); xmlWriter.write(document); xmlWriter.close(); &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://conjurermaple.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://conjurermaple.github.io/tags/JAVA/"}]}]}